(* This file was generated by Eliom-distillery.
   Feel free to use it, modify it, and redistribute it as you wish. *)

let%server application_name = "creet_app"
let%client application_name = Eliom_client.get_application_name ()

module%shared Html = Eliom_content.Html.D

type%shared creet_status =
  | Healthy
  | Sick

type%shared creet_spec = {
  id : int;
  x : float;
  y : float;
  dir_x : float;
  dir_y : float;
  status : creet_status;
}

let%shared initial_creets =
  [
    { id = 1; x = 40.; y = 60.; dir_x = 1.; dir_y = 0.3; status = Healthy };
    { id = 2; x = 160.; y = 140.; dir_x = -0.6; dir_y = 0.9; status = Healthy };
    { id = 3; x = 280.; y = 90.; dir_x = 0.2; dir_y = -1.; status = Healthy };
  ]

(* Create a module for the application. See
   https://ocsigen.org/eliom/manual/clientserver-applications for more
   information. *)
module%shared App = Eliom_registration.App (struct
    let application_name = application_name
    let global_data_path = Some ["__global_data__"]
  end)

(* As the headers (stylesheets, etc) won't change, we ask Eliom not to
   update the <head> of the page when changing page. (This also avoids
   blinking when changing page in iOS). *)
let%client _ = Eliom_client.persist_document_head ()

module%client Config = struct
  (* Random direction change settings *)
  let initial_chance = -10.
  let step = 5.
  let max_chance = 40.
  let reproduction_chance = 5.
  
  (* Game loop settings *)
  let frame_duration = 0.02
  
  (* Movement settings *)
  let speed = 60.
  let sick_speed_modifier = 0.85
  let speed_increment_per_second = 0.01
  
  (* Infection settings *)
  let infection_chance = 2.
  
  (* Map dimensions *)
  let map_width = 420.
  let map_height = 260.
  
  (* Creet size *)
  let creet_size = 24.
end

module%client Map_canvas = struct
  open Js_of_ocaml

  let map_id = "creet-map"

  let create_empty () =
    let container = Dom_html.createDiv Dom_html.document in
    container##.id := Js.string map_id;
    container##.className := Js.string "map-area";
    container
end

module%client Creet = struct
  open Js_of_ocaml

  let normalize dx dy =
    let mag = sqrt ((dx *. dx) +. (dy *. dy)) in
    if mag = 0. then (1., 0.) else (dx /. mag, dy /. mag)

  type t = {
    spec : creet_spec;
    node : Dom_html.divElement Js.t;
    mutable x : float;
    mutable y : float;
    mutable dir_x : float;
    mutable dir_y : float;
    mutable time_since_last_change : float;
    mutable reproduction_timer : float;
    mutable status : creet_status;
    mutable grabbed : bool;
  }

  let add_sick_creet_ref : (t -> unit) ref = ref (fun _ -> ())
  let remove_sick_creet_ref : (t -> unit) ref = ref (fun _ -> ())

  let create_node (spec : creet_spec) =
    let node = Dom_html.createDiv Dom_html.document in
    node##.className := Js.string "creet";
    node##.style##.left := Js.string (Printf.sprintf "%gpx" spec.x);
    node##.style##.top := Js.string (Printf.sprintf "%gpx" spec.y);
    node

  let apply_status_style creet =
    let base_class =
      match creet.status with
      | Healthy -> "creet"
      | Sick -> "creet creet--sick"
    in
    let full_class =
      if creet.grabbed then base_class ^ " creet--grabbed" else base_class
    in
    creet.node##.className := Js.string full_class;
    if creet.grabbed then creet.node##.style##.zIndex := Js.string "1000"
    else creet.node##.style##.zIndex := Js.string "1"

  let spawn (config : creet_spec) map_container =
    let node = create_node config in
    node##.style##.left := Js.string (Printf.sprintf "%gpx" config.x);
    node##.style##.top := Js.string (Printf.sprintf "%gpx" config.y);
    Dom.appendChild map_container node;
    let dir_x, dir_y = normalize config.dir_x config.dir_y in
    {
      spec = config;
      node;
      x = config.x;
      y = config.y;
      dir_x;
      dir_y;
      time_since_last_change = 0.;
      reproduction_timer = 0.;
      status = config.status;
      grabbed = false;
    }
    |> fun creet ->
    apply_status_style creet;
    creet

  let update_position creet =
    creet.node##.style##.left := Js.string (Printf.sprintf "%gpx" creet.x);
    creet.node##.style##.top := Js.string (Printf.sprintf "%gpx" creet.y)

  let become_sick creet =
    if creet.status <> Sick then (
      creet.status <- Sick;
      apply_status_style creet;
      !add_sick_creet_ref creet)

  let become_healthy creet =
    if creet.status <> Healthy then (
      creet.status <- Healthy;
      apply_status_style creet;
      !remove_sick_creet_ref creet)

  let set_grabbed creet grabbed =
    creet.grabbed <- grabbed;
    apply_status_style creet

  let contains_point creet x y =
    let creet_size = Config.creet_size in
    x >= creet.x && x <= creet.x +. creet_size
    && y >= creet.y && y <= creet.y +. creet_size

  let find_at_position x y creets =
    List.find_opt (fun creet -> contains_point creet x y) creets
end

module%client Quadtree = struct
  type bounds = {
    x : float;
    y : float;
    width : float;
    height : float;
  }

  type t =
    | Empty
    | Leaf of { bounds : bounds; creets : Creet.t list }
    | Node of {
        bounds : bounds;
        nw : t;
        ne : t;
        sw : t;
        se : t;
      }

  let create_bounds x y width height = { x; y; width; height }

  let intersects bounds1 bounds2 =
    not
      (bounds1.x +. bounds1.width <= bounds2.x
      || bounds2.x +. bounds2.width <= bounds1.x
      || bounds1.y +. bounds1.height <= bounds2.y
      || bounds2.y +. bounds2.height <= bounds1.y)

  let get_creet_bounds (creet : Creet.t) : bounds =
    {
      x = creet.x;
      y = creet.y;
      width = Config.creet_size;
      height = Config.creet_size;
    }

  let max_objects = 4
  let max_depth = 6

  let subdivide bounds =
    let half_w = bounds.width /. 2. in
    let half_h = bounds.height /. 2. in
    let nw = create_bounds bounds.x bounds.y half_w half_h in
    let ne = create_bounds (bounds.x +. half_w) bounds.y half_w half_h in
    let sw = create_bounds bounds.x (bounds.y +. half_h) half_w half_h in
    let se =
      create_bounds (bounds.x +. half_w) (bounds.y +. half_h) half_w half_h
    in
    (nw, ne, sw, se)

  let rec insert (creet : Creet.t) bounds_param depth tree =
    let creet_bounds = get_creet_bounds creet in
    if not (intersects bounds_param creet_bounds) then tree
    else
      match tree with
      | Empty ->
          let creets_list : Creet.t list = [ creet ] in
          Leaf { bounds = bounds_param; creets = creets_list }
      | Leaf leaf ->
          if depth >= max_depth || List.length leaf.creets < max_objects then
            Leaf { bounds = bounds_param; creets = creet :: leaf.creets }
          else (
            let nw, ne, sw, se = subdivide bounds_param in
            let empty = Empty in
            let nw_tree = List.fold_left
                            (fun t c -> insert c nw (depth + 1) t)
                            empty leaf.creets in
            let ne_tree = List.fold_left
                            (fun t c -> insert c ne (depth + 1) t)
                            empty leaf.creets in
            let sw_tree = List.fold_left
                            (fun t c -> insert c sw (depth + 1) t)
                            empty leaf.creets in
            let se_tree = List.fold_left
                            (fun t c -> insert c se (depth + 1) t)
                            empty leaf.creets in
            insert creet bounds_param depth
              (Node {
                  bounds = bounds_param;
                  nw = nw_tree;
                  ne = ne_tree;
                  sw = sw_tree;
                  se = se_tree;
                }))
      | Node node ->
          let nw, ne, sw, se = subdivide bounds_param in
          Node
            {
              bounds = bounds_param;
              nw = insert creet nw (depth + 1) node.nw;
              ne = insert creet ne (depth + 1) node.ne;
              sw = insert creet sw (depth + 1) node.sw;
              se = insert creet se (depth + 1) node.se;
            }

  let rec query bounds tree acc =
    match tree with
    | Empty -> acc
    | Leaf leaf ->
        if intersects bounds leaf.bounds then
          List.fold_left
            (fun acc creet ->
              let creet_bounds = get_creet_bounds creet in
              if intersects bounds creet_bounds then creet :: acc else acc)
            acc leaf.creets
        else acc
    | Node node ->
        if intersects bounds node.bounds then
          query bounds node.nw acc
          |> query bounds node.ne
          |> query bounds node.sw
          |> query bounds node.se
        else acc

  let build creets =
    let bounds =
      create_bounds 0. 0. Config.map_width Config.map_height
    in
    List.fold_left (fun tree creet -> insert creet bounds 0 tree) Empty creets

  let find_nearby creet tree =
    let creet_bounds = get_creet_bounds creet in
    query creet_bounds tree []
end

module%client State = struct
  open Js_of_ocaml
  let active_creets : Creet.t list ref = ref []
  let sick_creets : Creet.t list ref = ref []
  let map_container : Dom_html.divElement Js.t option ref = ref None
  let next_id = ref 0

  let register_map map = map_container := Some map
  let set_creets (creets : Creet.t list) =
    active_creets := creets;
    sick_creets := List.filter (fun (c : Creet.t) -> c.status = Sick) creets

  let set_next_id value = next_id := value

  let fresh_id () =
    let id = !next_id in
    incr next_id;
    id

  let add_creet creet =
    active_creets := creet :: !active_creets;
    if creet.status = Sick then sick_creets := creet :: !sick_creets

  let add_sick_creet creet = sick_creets := creet :: !sick_creets

  let remove_sick_creet creet =
    sick_creets := List.filter (fun c -> c != creet) !sick_creets

  let () =
    Creet.add_sick_creet_ref := add_sick_creet;
    Creet.remove_sick_creet_ref := remove_sick_creet

  let spawn_spec spec =
    match !map_container with
    | None -> None
    | Some map ->
        let creet = Creet.spawn spec map in
        add_creet creet;
        Some creet
end

module%client Interaction = struct
  open Js_of_ocaml
  open Js_of_ocaml_lwt
  open Lwt.Infix

  let grabbed_creet : Creet.t option ref = ref None
  let grab_offset : (float * float) option ref = ref None
  let has_dragged : bool ref = ref false
  let just_released : bool ref = ref false

  let get_map_position (ev : Dom_html.mouseEvent Js.t) =
    match !(State.map_container) with
    | None -> None
    | Some map ->
        let rect = map##getBoundingClientRect in
        let x = float_of_int ev##.clientX -. rect##.left in
        let y = float_of_int ev##.clientY -. rect##.top in
        Some (x, y)

  let clamp_to_bounds x y =
    let min_x = 0. in
    let min_y = 0. in
    let max_x = Config.map_width -. Config.creet_size in
    let max_y = Config.map_height -. Config.creet_size in
    let x = max min_x (min x max_x) in
    let y = max min_y (min y max_y) in
    (x, y)

  let release_creet ?(hit_bottom_wall = false) () =
    match !grabbed_creet with
    | None -> ()
    | Some creet ->
        Creet.set_grabbed creet false;
        if hit_bottom_wall && creet.status = Sick then Creet.become_healthy creet;
        grabbed_creet := None;
        grab_offset := None;
        has_dragged := false;
        just_released := true;
        Lwt.async (fun () ->
            Lwt_js.yield () >|= fun () -> just_released := false);
        match !(State.map_container) with
        | None -> ()
        | Some map -> map##.classList##remove (Js.string "grabbing")

  let handle_click (ev : Dom_html.mouseEvent Js.t) =
    if !just_released then (
      just_released := false;
      ())
    else
      match get_map_position ev with
      | None -> ()
      | Some (x, y) -> (
          match !grabbed_creet with
          | Some _ -> release_creet ()
          | None -> (
            let creets = List.rev !(State.active_creets) in
            match Creet.find_at_position x y creets with
            | None -> ()
            | Some creet ->
                if creet.status = Sick then (
                  let offset_x = x -. creet.x in
                  let offset_y = y -. creet.y in
                  grab_offset := Some (offset_x, offset_y);
                  has_dragged := false;
                  Creet.set_grabbed creet true;
                  grabbed_creet := Some creet;
                  match !(State.map_container) with
                  | None -> ()
                  | Some map -> map##.classList##add (Js.string "grabbing"))))

  let handle_mousemove (ev : Dom_html.mouseEvent Js.t) =
    match !grabbed_creet with
    | None -> ()
    | Some creet -> (
        has_dragged := true;
        match get_map_position ev with
        | None -> release_creet ()
        | Some (mouse_x, mouse_y) -> (
            match !grab_offset with
            | None -> release_creet ()
            | Some (offset_x, offset_y) ->
                let x = mouse_x -. offset_x in
                let y = mouse_y -. offset_y in
                let x, y = clamp_to_bounds x y in
                creet.x <- x;
                creet.y <- y;
                Creet.update_position creet;
                let min_x = 0. in
                let min_y = 0. in
                let max_x = Config.map_width -. Config.creet_size in
                let max_y = Config.map_height -. Config.creet_size in
                if y >= max_y then
                  release_creet ~hit_bottom_wall:true ()
                else if x <= min_x || x >= max_x || y <= min_y then
                  release_creet ()))

  let setup map =
    let map_element = (map :> Dom_html.element Js.t) in
    Lwt.async (fun () ->
        Lwt_js_events.mousedowns map_element (fun ev _ ->
            handle_click ev;
            Lwt.return_unit));
    Lwt.async (fun () ->
        Lwt_js_events.mousemoves map_element (fun ev _ ->
            handle_mousemove ev;
            Lwt.return_unit));
    Lwt.async (fun () ->
        Lwt_js_events.mouseups map_element (fun _ev _ ->
            if !has_dragged then (
              match !grabbed_creet with
              | Some _ -> release_creet ()
              | None -> ());
            Lwt.return_unit))
end

module%client Counters = struct
  open Js_of_ocaml

  let healthy_counter_id = "healthy-counter"
  let sick_counter_id = "sick-counter"

  let update () =
    let creets : Creet.t list = !(State.active_creets) in
    let healthy_count =
      List.fold_left
        (fun acc (creet : Creet.t) ->
          if creet.status = Healthy then acc + 1 else acc)
        0 creets
    in
    let sick_count =
      List.fold_left
        (fun acc (creet : Creet.t) ->
          if creet.status = Sick then acc + 1 else acc)
        0 creets
    in
    let healthy_elem =
      Js.Opt.to_option
        (Dom_html.document##getElementById (Js.string healthy_counter_id))
    in
    let sick_elem =
      Js.Opt.to_option
        (Dom_html.document##getElementById (Js.string sick_counter_id))
    in
    match (healthy_elem, sick_elem) with
    | Some h, Some s ->
        h##.textContent :=
          Js.some (Js.string (string_of_int healthy_count));
        s##.textContent := Js.some (Js.string (string_of_int sick_count))
    | _ -> ()
end

module%client Game_loop = struct
  open Js_of_ocaml
  open Js_of_ocaml_lwt
  open Lwt.Infix

  let elapsed_time : float ref = ref 0.

  let min_x = 0.
  let min_y = 0.
  let max_x = Config.map_width -. Config.creet_size
  let max_y = Config.map_height -. Config.creet_size

  let clamp v low high =
    max low (min v high)

  let normalize dx dy =
    let mag = sqrt ((dx *. dx) +. (dy *. dy)) in
    if mag = 0. then (1., 0.) else (dx /. mag, dy /. mag)

  let reflect (creet : Creet.t) hit_x hit_y =
    if hit_x then creet.dir_x <- -.creet.dir_x;
    if hit_y then creet.dir_y <- -.creet.dir_y;
    let dir_x, dir_y = normalize creet.dir_x creet.dir_y in
    creet.dir_x <- dir_x;
    creet.dir_y <- dir_y

  let random_direction () =
    let angle = (Js.math##random) *. 2. *. 3.141592653589793 in
    normalize (cos angle) (sin angle)

  let should_turn (creet : Creet.t) =
    let threshold = Config.initial_chance +. (Config.step *. creet.time_since_last_change) in
    if threshold <= 0. then false
    else
      let clamped_threshold = min threshold Config.max_chance in
      let random_val = (Js.math##random) *. 100. in
      random_val < clamped_threshold

  let random_turn (creet : Creet.t) =
    let dir_x, dir_y = random_direction () in
    creet.dir_x <- dir_x;
    creet.dir_y <- dir_y;
    creet.time_since_last_change <- 0.

  let attempt_reproduction (creet : Creet.t) =
    if creet.status = Sick then ()
    else (
      creet.reproduction_timer <- creet.reproduction_timer +. Config.frame_duration;
      let rec loop () =
        if creet.reproduction_timer >= 1. then (
          creet.reproduction_timer <- creet.reproduction_timer -. 1.;
          let roll = (Js.math##random) *. 100. in
          if roll < Config.reproduction_chance then (
            let dir_x, dir_y = random_direction () in
            let spec =
              {
                id = State.fresh_id ();
                x = creet.x;
                y = creet.y;
                dir_x;
                dir_y;
                status = Healthy;
              }
            in
            ignore (State.spawn_spec spec));
          loop ())
      in
      loop ())
  let handle_bounds (creet : Creet.t) =
    let hit_left = creet.x <= min_x && creet.dir_x < 0. in
    let hit_right = creet.x >= max_x && creet.dir_x > 0. in
    let hit_top = creet.y <= min_y && creet.dir_y < 0. in
    let hit_bottom = creet.y >= max_y && creet.dir_y > 0. in
    let hit_x = hit_left || hit_right in
    let hit_y = hit_top || hit_bottom in
    if hit_x || hit_y then (
      reflect creet hit_x hit_y;
      if hit_top then Creet.become_sick creet;
      creet.x <- clamp creet.x min_x max_x;
      creet.y <- clamp creet.y min_y max_y)

  let creets_collide (creet1 : Creet.t) (creet2 : Creet.t) =
    let size = Config.creet_size in
    creet1.x < creet2.x +. size && creet1.x +. size > creet2.x
    && creet1.y < creet2.y +. size && creet1.y +. size > creet2.y

  let handle_collisions tree =
    List.iter
      (fun (sick_creet : Creet.t) ->
        if not sick_creet.grabbed then (
          let nearby = Quadtree.find_nearby sick_creet tree in
          List.iter
            (fun (other_creet : Creet.t) ->
              if
                other_creet.status = Healthy
                && not other_creet.grabbed
                && creets_collide sick_creet other_creet
              then (
                let roll = (Js.math##random) *. 100. in
                if roll < Config.infection_chance then Creet.become_sick other_creet))
            nearby))
      !(State.sick_creets)

  let advance (creet : Creet.t) =
    if creet.grabbed then (
      Creet.update_position creet)
    else (
      creet.time_since_last_change <- creet.time_since_last_change +. Config.frame_duration;
      if should_turn creet then random_turn creet;
      attempt_reproduction creet;
      let current_speed = Config.speed +. (Config.speed_increment_per_second *. !elapsed_time) in
      let step = current_speed *. (if creet.status = Sick then Config.sick_speed_modifier else 1.) *. Config.frame_duration in
      creet.x <- creet.x +. (creet.dir_x *. step);
      creet.y <- creet.y +. (creet.dir_y *. step);
      creet.x <- clamp creet.x min_x max_x;
      creet.y <- clamp creet.y min_y max_y;
      handle_bounds creet;
      Creet.update_position creet)

  let rec tick () =
    elapsed_time := !elapsed_time +. Config.frame_duration;
    List.iter advance !(State.active_creets);
    let tree = Quadtree.build !(State.active_creets) in
    handle_collisions tree;
    Counters.update ();
    Lwt_js.sleep Config.frame_duration >>= tick

  let start () = Lwt.async (fun () -> tick ())
end

module%client World = struct
  open Js_of_ocaml

  let root_id = "app-root"

  let get_root () =
    Js.Opt.to_option
      (Dom_html.document##getElementById (Js.string root_id))

  let mount () =
    match get_root () with
    | None -> ()
    | Some root ->
        let map = Map_canvas.create_empty () in
        Dom.appendChild root map;
        State.register_map map;
        Interaction.setup map;
        let shared_creets = ~%initial_creets in
        let next_id =
          List.fold_left (fun acc spec -> max acc spec.id) 0 shared_creets + 1
        in
        State.set_next_id next_id;
        let creets = List.map (fun spec -> Creet.spawn spec map) shared_creets in
        State.set_creets creets;
        Game_loop.start ()
end

let%client () =
  let open Js_of_ocaml in
  let handler _ =
    World.mount ();
    Js._false
  in
  Dom_html.window##.onload := Dom_html.handler handler

let%server main_service =
  Eliom_service.create ~path:(Eliom_service.Path [])
    ~meth:(Eliom_service.Get Eliom_parameter.unit) ()

let%client main_service = ~%main_service

let%shared () =
  App.register ~service:main_service (fun () () ->
    Lwt.return
      Html.(
        html
          (head
             (title (txt "Creet MVP"))
             [
               css_link
                 ~uri:
                   (make_uri
                      ~service:(Eliom_service.static_dir ())
                      ["css"; "creet_app.css"])
                 ();
             ])
          (body
             [
               h1 [txt "Creet MVP"];
               div
                 ~a:[
                   a_id "app-root";
                   a_class ["app-root"];
                   a_user_data
                     "creet-count"
                     (string_of_int (List.length initial_creets));
                 ]
                 [];
               div
                 ~a:[
                   a_id "healthy-counter";
                   a_class ["counter"; "counter--healthy"];
                 ]
                 [txt "0"];
               div
                 ~a:[
                   a_id "sick-counter";
                   a_class ["counter"; "counter--sick"];
                 ]
                 [txt "0"];
             ])))
