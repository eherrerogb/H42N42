(* This file was generated by Eliom-distillery.
   Feel free to use it, modify it, and redistribute it as you wish. *)

let%server application_name = "creet_app"
let%client application_name = Eliom_client.get_application_name ()

module%shared Html = Eliom_content.Html.D

type%shared creet_spec = {
  id : int;
  x : float;
  y : float;
  dir_x : float;
  dir_y : float;
}

let%shared initial_creets =
  [
    { id = 1; x = 40.; y = 60.; dir_x = 1.; dir_y = 0.3 };
    { id = 2; x = 160.; y = 140.; dir_x = -0.6; dir_y = 0.9 };
    { id = 3; x = 280.; y = 90.; dir_x = 0.2; dir_y = -1. };
  ]

(* Create a module for the application. See
   https://ocsigen.org/eliom/manual/clientserver-applications for more
   information. *)
module%shared App = Eliom_registration.App (struct
    let application_name = application_name
    let global_data_path = Some ["__global_data__"]
  end)

(* As the headers (stylesheets, etc) won't change, we ask Eliom not to
   update the <head> of the page when changing page. (This also avoids
   blinking when changing page in iOS). *)
let%client _ = Eliom_client.persist_document_head ()

module%client Config = struct
  (* Random direction change settings *)
  let initial_chance = -10.
  let step = 5.
  let max_chance = 40.
  let reproduction_chance = 5.
  
  (* Game loop settings *)
  let frame_duration = 0.02
  
  (* Movement settings *)
  let speed = 60.
  
  (* Map dimensions *)
  let map_width = 420.
  let map_height = 260.
  
  (* Creet size *)
  let creet_size = 24.
end

module%client Map_canvas = struct
  open Js_of_ocaml

  let map_id = "creet-map"

  let create_empty () =
    let container = Dom_html.createDiv Dom_html.document in
    container##.id := Js.string map_id;
    container##.className := Js.string "map-area";
    container
end

module%client Creet = struct
  open Js_of_ocaml

  let normalize dx dy =
    let mag = sqrt ((dx *. dx) +. (dy *. dy)) in
    if mag = 0. then (1., 0.) else (dx /. mag, dy /. mag)

  type t = {
    spec : creet_spec;
    node : Dom_html.divElement Js.t;
    mutable x : float;
    mutable y : float;
    mutable dir_x : float;
    mutable dir_y : float;
    mutable time_since_last_change : float;
    mutable reproduction_timer : float;
  }

  let create_node (spec : creet_spec) =
    let node = Dom_html.createDiv Dom_html.document in
    node##.className := Js.string "creet";
    node##.style##.left := Js.string (Printf.sprintf "%gpx" spec.x);
    node##.style##.top := Js.string (Printf.sprintf "%gpx" spec.y);
    node

  let spawn (config : creet_spec) map_container =
    let node = create_node config in
    node##.style##.left := Js.string (Printf.sprintf "%gpx" config.x);
    node##.style##.top := Js.string (Printf.sprintf "%gpx" config.y);
    Dom.appendChild map_container node;
    let dir_x, dir_y = normalize config.dir_x config.dir_y in
    {
      spec = config;
      node;
      x = config.x;
      y = config.y;
      dir_x;
      dir_y;
      time_since_last_change = 0.;
      reproduction_timer = 0.;
    }

  let update_position creet =
    creet.node##.style##.left := Js.string (Printf.sprintf "%gpx" creet.x);
    creet.node##.style##.top := Js.string (Printf.sprintf "%gpx" creet.y)
end

module%client State = struct
  open Js_of_ocaml
  let active_creets : Creet.t list ref = ref []
  let map_container : Dom_html.divElement Js.t option ref = ref None
  let next_id = ref 0

  let register_map map = map_container := Some map
  let set_creets creets = active_creets := creets

  let set_next_id value = next_id := value

  let fresh_id () =
    let id = !next_id in
    incr next_id;
    id

  let add_creet creet = active_creets := creet :: !active_creets

  let spawn_spec spec =
    match !map_container with
    | None -> None
    | Some map ->
        let creet = Creet.spawn spec map in
        add_creet creet;
        Some creet
end

module%client Game_loop = struct
  open Js_of_ocaml
  open Js_of_ocaml_lwt
  open Lwt.Infix

  let min_x = 0.
  let min_y = 0.
  let max_x = Config.map_width -. Config.creet_size
  let max_y = Config.map_height -. Config.creet_size

  let clamp v low high =
    max low (min v high)

  let normalize dx dy =
    let mag = sqrt ((dx *. dx) +. (dy *. dy)) in
    if mag = 0. then (1., 0.) else (dx /. mag, dy /. mag)

  let reflect (creet : Creet.t) hit_x hit_y =
    if hit_x then creet.dir_x <- -.creet.dir_x;
    if hit_y then creet.dir_y <- -.creet.dir_y;
    let dir_x, dir_y = normalize creet.dir_x creet.dir_y in
    creet.dir_x <- dir_x;
    creet.dir_y <- dir_y

  let random_direction () =
    let angle = (Js.math##random) *. 2. *. 3.141592653589793 in
    normalize (cos angle) (sin angle)

  let should_turn (creet : Creet.t) =
    let threshold = Config.initial_chance +. (Config.step *. creet.time_since_last_change) in
    if threshold <= 0. then false
    else
      let clamped_threshold = min threshold Config.max_chance in
      let random_val = (Js.math##random) *. 100. in
      random_val < clamped_threshold

  let random_turn (creet : Creet.t) =
    let dir_x, dir_y = random_direction () in
    creet.dir_x <- dir_x;
    creet.dir_y <- dir_y;
    creet.time_since_last_change <- 0.

  let attempt_reproduction (creet : Creet.t) =
    creet.reproduction_timer <- creet.reproduction_timer +. Config.frame_duration;
    let rec loop () =
      if creet.reproduction_timer >= 1. then (
        creet.reproduction_timer <- creet.reproduction_timer -. 1.;
        let roll = (Js.math##random) *. 100. in
        if roll < Config.reproduction_chance then (
          let dir_x, dir_y = random_direction () in
          let spec =
            {
              id = State.fresh_id ();
              x = creet.x;
              y = creet.y;
              dir_x;
              dir_y;
            }
          in
          ignore (State.spawn_spec spec));
        loop ())
    in
    loop ()
  let handle_bounds (creet : Creet.t) =
    let hit_x =
      if creet.x <= min_x && creet.dir_x < 0. then true
      else if creet.x >= max_x && creet.dir_x > 0. then true
      else false
    in
    let hit_y =
      if creet.y <= min_y && creet.dir_y < 0. then true
      else if creet.y >= max_y && creet.dir_y > 0. then true
      else false
    in
    if hit_x || hit_y then (
      reflect creet hit_x hit_y;
      creet.x <- clamp creet.x min_x max_x;
      creet.y <- clamp creet.y min_y max_y)

  let advance (creet : Creet.t) =
    creet.time_since_last_change <- creet.time_since_last_change +. Config.frame_duration;
    if should_turn creet then random_turn creet;
    attempt_reproduction creet;
    let step = Config.speed *. Config.frame_duration in
    creet.x <- creet.x +. (creet.dir_x *. step);
    creet.y <- creet.y +. (creet.dir_y *. step);
    creet.x <- clamp creet.x min_x max_x;
    creet.y <- clamp creet.y min_y max_y;
    handle_bounds creet;
    Creet.update_position creet

  let rec tick () =
    List.iter advance !(State.active_creets);
    Lwt_js.sleep Config.frame_duration >>= tick

  let start () = Lwt.async (fun () -> tick ())
end

module%client World = struct
  open Js_of_ocaml

  let root_id = "app-root"

  let get_root () =
    Js.Opt.to_option
      (Dom_html.document##getElementById (Js.string root_id))

  let mount () =
    match get_root () with
    | None -> ()
    | Some root ->
        let map = Map_canvas.create_empty () in
        Dom.appendChild root map;
        State.register_map map;
        let shared_creets = ~%initial_creets in
        let next_id =
          List.fold_left (fun acc spec -> max acc spec.id) 0 shared_creets + 1
        in
        State.set_next_id next_id;
        let creets = List.map (fun spec -> Creet.spawn spec map) shared_creets in
        State.set_creets creets;
        Game_loop.start ()
end

let%client () =
  let open Js_of_ocaml in
  let handler _ =
    World.mount ();
    Js._false
  in
  Dom_html.window##.onload := Dom_html.handler handler

let%server main_service =
  Eliom_service.create ~path:(Eliom_service.Path [])
    ~meth:(Eliom_service.Get Eliom_parameter.unit) ()

let%client main_service = ~%main_service

let%shared () =
  App.register ~service:main_service (fun () () ->
    Lwt.return
      Html.(
        html
          (head
             (title (txt "Creet MVP"))
             [
               css_link
                 ~uri:
                   (make_uri
                      ~service:(Eliom_service.static_dir ())
                      ["css"; "creet_app.css"])
                 ();
             ])
          (body
             [
               h1 [txt "Creet MVP"];
               div
                 ~a:[
                   a_id "app-root";
                   a_class ["app-root"];
                   a_user_data
                     "creet-count"
                     (string_of_int (List.length initial_creets));
                 ]
                 [];
             ])))
