(* This file was generated by Eliom-distillery.
   Feel free to use it, modify it, and redistribute it as you wish. *)

let%server application_name = "creet_app"
let%client application_name = Eliom_client.get_application_name ()

module%shared Html = Eliom_content.Html.D

type%shared creet_status =
  | Healthy
  | Sick
  | Berserk
  | Mean

type%shared creet_spec = {
  id : int;
  x : float;
  y : float;
  dir_x : float;
  dir_y : float;
  status : creet_status;
}

let%shared initial_creets =
  [
    { id = 1; x = 40.; y = 60.; dir_x = 1.; dir_y = 0.3; status = Healthy };
    { id = 2; x = 160.; y = 140.; dir_x = -0.6; dir_y = 0.9; status = Healthy };
    { id = 3; x = 280.; y = 90.; dir_x = 0.2; dir_y = -1.; status = Healthy };
  ]

(* Create a module for the application. See
   https://ocsigen.org/eliom/manual/clientserver-applications for more
   information. *)
module%shared App = Eliom_registration.App (struct
    let application_name = application_name
    let global_data_path = Some ["__global_data__"]
  end)

(* As the headers (stylesheets, etc) won't change, we ask Eliom not to
   update the <head> of the page when changing page. (This also avoids
   blinking when changing page in iOS). *)
let%client _ = Eliom_client.persist_document_head ()

module%client Config = struct
  (* Random direction change settings *)
  let initial_chance = -10.
  let step = 5.
  let max_chance = 40.
  let reproduction_chance = 5.
  
  (* Game loop settings *)
  let frame_duration = 0.02
  
  (* Movement settings *)
  let speed = 60.
  let sick_speed_modifier = 0.85
  let speed_increment_per_second = 0.01
  
  (* Infection settings *)
  let infection_chance = 2.
  
  (* Map dimensions *)
  let map_width = 420.
  let map_height = 260.
  
  (* Creet size *)
  let creet_size = 24.

  (* Berserk configuration *)
  let berserk_chance = 10.
  let berserk_size_increment_per_second = 1.
  let berserk_extra_size = 96.

  (* Mean configuration *)
  let mean_chance = 100.
  let mean_size = 20.
  let mean_detection_radius = 150.

  (* Healing configuration *)
  let healing_distance_threshold = 10. [@@ocaml.warning "-32"]

end

module%client Map_canvas = struct
  open Js_of_ocaml

  let map_id = "creet-map"

  let create_empty () =
    let container = Dom_html.createDiv Dom_html.document in
    container##.id := Js.string map_id;
    container##.className := Js.string "map-area";
    container
end

module%client Creet = struct
  open Js_of_ocaml

  let normalize dx dy =
    let mag = sqrt ((dx *. dx) +. (dy *. dy)) in
    if mag = 0. then (1., 0.) else (dx /. mag, dy /. mag)

  type t = {
    spec : creet_spec;
    node : Dom_html.divElement Js.t;
    mutable x : float;
    mutable y : float;
    mutable dir_x : float;
    mutable dir_y : float;
    mutable time_since_last_change : float;
    mutable reproduction_timer : float;
    mutable status : creet_status;
    mutable grabbed : bool;
    mutable size : float;
  }

  let add_sick_creet_ref : (t -> unit) ref = ref (fun _ -> ())
  let remove_sick_creet_ref : (t -> unit) ref = ref (fun _ -> ())

  let create_node (spec : creet_spec) =
    let node = Dom_html.createDiv Dom_html.document in
    node##.id := Js.string (Printf.sprintf "creet-%d" spec.id);
    node##.className := Js.string "creet";
    node##.style##.left := Js.string (Printf.sprintf "%gpx" spec.x);
    node##.style##.top := Js.string (Printf.sprintf "%gpx" spec.y);
    node

  let apply_status_style creet =
    let base_class =
      match creet.status with
      | Healthy -> "creet"
      | Sick -> "creet creet--sick"
      | Berserk -> "creet creet--sick creet--berserk"
      | Mean -> "creet creet--sick creet--mean"
    in
    let full_class =
      if creet.grabbed then base_class ^ " creet--grabbed" else base_class
    in
    creet.node##.className := Js.string full_class;
    if creet.grabbed then creet.node##.style##.zIndex := Js.string "1000"
    else creet.node##.style##.zIndex := Js.string "1"

  let update_size creet =
    creet.node##.style##.width := Js.string (Printf.sprintf "%gpx" creet.size);
    creet.node##.style##.height := Js.string (Printf.sprintf "%gpx" creet.size)

  let spawn (config : creet_spec) map_container =
    let node = create_node config in
    node##.style##.left := Js.string (Printf.sprintf "%gpx" config.x);
    node##.style##.top := Js.string (Printf.sprintf "%gpx" config.y);
    Dom.appendChild map_container node;
    let dir_x, dir_y = normalize config.dir_x config.dir_y in
    {
      spec = config;
      node;
      x = config.x;
      y = config.y;
      dir_x;
      dir_y;
      time_since_last_change = 0.;
      reproduction_timer = 0.;
      status = config.status;
      grabbed = false;
      size = Config.creet_size;
    }
    |> fun creet ->
    apply_status_style creet;
    update_size creet;
    creet

  let update_position creet =
    creet.node##.style##.left := Js.string (Printf.sprintf "%gpx" creet.x);
    creet.node##.style##.top := Js.string (Printf.sprintf "%gpx" creet.y)

  let become_sick creet =
    if creet.status = Healthy then (
      let roll = (Js.math##random) *. 100. in
      if roll < Config.berserk_chance then (
        creet.status <- Berserk)
      else if roll < Config.berserk_chance +. Config.mean_chance then (
        creet.status <- Mean;
        creet.size <- Config.mean_size)
      else (
        creet.status <- Sick);
      apply_status_style creet;
      update_size creet;
      !add_sick_creet_ref creet)

  let become_healthy creet =
    if creet.status <> Healthy then (
      creet.status <- Healthy;
      creet.size <- Config.creet_size;
      apply_status_style creet;
      update_size creet;
      !remove_sick_creet_ref creet)

  let set_grabbed creet grabbed =
    creet.grabbed <- grabbed;
    apply_status_style creet

end

module%client Quadtree = struct
  type bounds = {
    x : float;
    y : float;
    width : float;
    height : float;
  }

  type t =
    | Empty
    | Leaf of { bounds : bounds; creets : Creet.t list }
    | Node of {
        bounds : bounds;
        nw : t;
        ne : t;
        sw : t;
        se : t;
      }

  let create_bounds x y width height = { x; y; width; height }

  let intersects bounds1 bounds2 =
    not
      (bounds1.x +. bounds1.width <= bounds2.x
      || bounds2.x +. bounds2.width <= bounds1.x
      || bounds1.y +. bounds1.height <= bounds2.y
      || bounds2.y +. bounds2.height <= bounds1.y)

  let get_creet_bounds (creet : Creet.t) : bounds =
    {
      x = creet.x;
      y = creet.y;
      width = creet.size;
      height = creet.size;
    }

  let max_objects = 4
  let max_depth = 6

  let subdivide bounds =
    let half_w = bounds.width /. 2. in
    let half_h = bounds.height /. 2. in
    let nw = create_bounds bounds.x bounds.y half_w half_h in
    let ne = create_bounds (bounds.x +. half_w) bounds.y half_w half_h in
    let sw = create_bounds bounds.x (bounds.y +. half_h) half_w half_h in
    let se =
      create_bounds (bounds.x +. half_w) (bounds.y +. half_h) half_w half_h
    in
    (nw, ne, sw, se)

  let rec insert (creet : Creet.t) bounds_param depth tree =
    let creet_bounds = get_creet_bounds creet in
    if not (intersects bounds_param creet_bounds) then tree
    else
      match tree with
      | Empty ->
          let creets_list : Creet.t list = [ creet ] in
          Leaf { bounds = bounds_param; creets = creets_list }
      | Leaf leaf ->
          if depth >= max_depth || List.length leaf.creets < max_objects then
            Leaf { bounds = bounds_param; creets = creet :: leaf.creets }
          else (
            let nw, ne, sw, se = subdivide bounds_param in
            let empty = Empty in
            let nw_tree = List.fold_left
                            (fun t c -> insert c nw (depth + 1) t)
                            empty leaf.creets in
            let ne_tree = List.fold_left
                            (fun t c -> insert c ne (depth + 1) t)
                            empty leaf.creets in
            let sw_tree = List.fold_left
                            (fun t c -> insert c sw (depth + 1) t)
                            empty leaf.creets in
            let se_tree = List.fold_left
                            (fun t c -> insert c se (depth + 1) t)
                            empty leaf.creets in
            insert creet bounds_param depth
              (Node {
                  bounds = bounds_param;
                  nw = nw_tree;
                  ne = ne_tree;
                  sw = sw_tree;
                  se = se_tree;
                }))
      | Node node ->
          let nw, ne, sw, se = subdivide bounds_param in
          Node
            {
              bounds = bounds_param;
              nw = insert creet nw (depth + 1) node.nw;
              ne = insert creet ne (depth + 1) node.ne;
              sw = insert creet sw (depth + 1) node.sw;
              se = insert creet se (depth + 1) node.se;
            }

  let rec query bounds tree acc =
    match tree with
    | Empty -> acc
    | Leaf leaf ->
        if intersects bounds leaf.bounds then
          List.fold_left
            (fun acc creet ->
              let creet_bounds = get_creet_bounds creet in
              if intersects bounds creet_bounds then creet :: acc else acc)
            acc leaf.creets
        else acc
    | Node node ->
        if intersects bounds node.bounds then
          query bounds node.nw acc
          |> query bounds node.ne
          |> query bounds node.sw
          |> query bounds node.se
        else acc

  let build creets =
    let bounds =
      create_bounds 0. 0. Config.map_width Config.map_height
    in
    List.fold_left (fun tree creet -> insert creet bounds 0 tree) Empty creets

  let find_nearby creet tree =
    let creet_bounds = get_creet_bounds creet in
    query creet_bounds tree []

  let query_circle center_x center_y radius tree =
    let bounds =
      create_bounds
        (center_x -. radius)
        (center_y -. radius)
        (radius *. 2.)
        (radius *. 2.)
    in
    query bounds tree []

end

module%client State = struct
  open Js_of_ocaml
  let active_creets : Creet.t list ref = ref []
  let sick_creets : Creet.t list ref = ref []
  let map_container : Dom_html.divElement Js.t option ref = ref None
  let next_id = ref 0

  let register_map map = map_container := Some map
  let set_creets (creets : Creet.t list) =
    active_creets := creets;
    sick_creets :=
      List.filter
        (fun (c : Creet.t) -> c.status <> Healthy)
        creets

  let set_next_id value = next_id := value

  let fresh_id () =
    let id = !next_id in
    incr next_id;
    id

  let add_creet creet =
    active_creets := creet :: !active_creets;
    if creet.status <> Healthy then
      sick_creets := creet :: !sick_creets

  let add_sick_creet creet = sick_creets := creet :: !sick_creets

  let remove_sick_creet creet =
    sick_creets := List.filter (fun c -> c != creet) !sick_creets

  let () =
    Creet.add_sick_creet_ref := add_sick_creet;
    Creet.remove_sick_creet_ref := remove_sick_creet

  let spawn_spec spec =
    match !map_container with
    | None -> None
    | Some map ->
        let creet = Creet.spawn spec map in
        add_creet creet;
        Some creet
end

module%client Interaction = struct
  open Js_of_ocaml
  open Js_of_ocaml_lwt

  let grabbed_creet : Creet.t option ref = ref None
  let grab_offset : (float * float) option ref = ref None

  let get_map_position (ev : Dom_html.mouseEvent Js.t) =
    match !(State.map_container) with
    | None -> None
    | Some map ->
        let rect = map##getBoundingClientRect in
        let x = float_of_int ev##.clientX -. rect##.left in
        let y = float_of_int ev##.clientY -. rect##.top in
        Some (x, y)

  let clamp_to_bounds (creet : Creet.t) x y =
    let min_x = 0. in
    let min_y = 0. in
    let max_x = Config.map_width -. creet.size in
    let max_y = Config.map_height -. creet.size in
    let x = max min_x (min x max_x) in
    let y = max min_y (min y max_y) in
    (x, y)

  let check_and_heal_if_close_to_bottom (creet : Creet.t) =
    let bottom_wall_y = Config.map_height in
    let creet_bottom_y = creet.y +. creet.size in
    let distance_to_bottom = bottom_wall_y -. creet_bottom_y in
    if distance_to_bottom <= Config.healing_distance_threshold && distance_to_bottom >= 0. then (
      if creet.status <> Healthy then
        Creet.become_healthy creet)

  let release_creet () =
    match !grabbed_creet with
    | None -> ()
    | Some creet ->
        Creet.set_grabbed creet false;
        check_and_heal_if_close_to_bottom creet;
        grabbed_creet := None;
        grab_offset := None;
        match !(State.map_container) with
        | None -> ()
        | Some map -> map##.classList##remove (Js.string "grabbing")

  let handle_click (ev : Dom_html.mouseEvent Js.t) =
    match get_map_position ev with
    | None -> ()
    | Some (x, y) -> (
        match !grabbed_creet with
        | Some _ -> release_creet ()
        | None -> (
          (* Use event target to find which element was clicked *)
          let clicked_element = Js.Opt.to_option ev##.target in
          match clicked_element with
          | None -> ()
          | Some element -> (
              (* Walk up the DOM tree to find an element with a creet ID *)
              let rec find_creet_id (el : Dom_html.element Js.t) =
                let id = Js.to_string el##.id in
                if String.length id > 6 && String.sub id 0 6 = "creet-" then (
                  try
                    let creet_id = int_of_string (String.sub id 6 (String.length id - 6)) in
                    Some creet_id
                  with _ -> None)
                else (
                  match Js.Opt.to_option el##.parentNode with
                  | None -> None
                  | Some parent_node -> (
                      try
                        let parent_el : Dom_html.element Js.t =
                          Js.Unsafe.coerce parent_node
                        in
                        find_creet_id parent_el
                      with _ -> None))
              in
              match find_creet_id element with
              | None -> ()
              | Some creet_id -> (
                  (* Find the Creet.t object with this ID *)
                  let creets = !(State.active_creets) in
                  let found_creet =
                    List.find_opt
                      (fun (creet : Creet.t) -> creet.spec.id = creet_id)
                      creets
                  in
                  match found_creet with
                  | None -> ()
                  | Some creet ->
                      if creet.status <> Healthy then (
                        let offset_x = x -. creet.x in
                        let offset_y = y -. creet.y in
                        grab_offset := Some (offset_x, offset_y);
                        Creet.set_grabbed creet true;
                        grabbed_creet := Some creet;
                        let console = Js.Unsafe.global##.console in
                        ignore
                          (console##log
                             (Js.string
                                ("Grab successful: Click at ("
                               ^ string_of_float x ^ ", " ^ string_of_float y
                               ^ "), grabbed creet at (" ^ string_of_float creet.x
                               ^ ", " ^ string_of_float creet.y ^ ")")));
                        match !(State.map_container) with
                        | None -> ()
                        | Some map -> map##.classList##add (Js.string "grabbing"))
                      else (
                        let console = Js.Unsafe.global##.console in
                        ignore
                          (console##log
                             (Js.string
                                ("Grab failed: Creet at ("
                               ^ string_of_float creet.x ^ ", "
                               ^ string_of_float creet.y
                               ^ ") is not sick"))))))))

  let handle_mousemove (ev : Dom_html.mouseEvent Js.t) =
    match !grabbed_creet with
    | None -> ()
    | Some creet -> (
        match get_map_position ev with
        | None -> release_creet ()
        | Some (mouse_x, mouse_y) -> (
            (* Check if cursor is outside map bounds *)
            if mouse_x < 0. || mouse_x > Config.map_width || mouse_y < 0. || mouse_y > Config.map_height
            then release_creet ()
            else (
              match !grab_offset with
              | None -> release_creet ()
              | Some (offset_x, offset_y) ->
                  let x = mouse_x -. offset_x in
                  let y = mouse_y -. offset_y in
                  let x, y = clamp_to_bounds creet x y in
                  creet.x <- x;
                  creet.y <- y;
                  Creet.update_position creet;
                  let min_x = 0. in
                  let min_y = 0. in
                  let max_x = Config.map_width -. creet.size in
                  let max_y = Config.map_height -. creet.size in
                  if x <= min_x || x >= max_x || y <= min_y || y >= max_y then
                    release_creet ())))

  let setup map =
    let map_element = (map :> Dom_html.element Js.t) in
    Lwt.async (fun () ->
        Lwt_js_events.mousedowns map_element (fun ev _ ->
            handle_click ev;
            Lwt.return_unit));
    Lwt.async (fun () ->
        Lwt_js_events.mousemoves map_element (fun ev _ ->
            handle_mousemove ev;
            Lwt.return_unit));
    (* Also listen to document-level mousemove to catch fast movements outside map *)
    Lwt.async (fun () ->
        Lwt_js_events.mousemoves Dom_html.document##.documentElement (fun ev _ ->
            match !grabbed_creet with
            | None -> Lwt.return_unit
            | Some _ -> (
                match get_map_position ev with
                | None -> (
                    release_creet ();
                    Lwt.return_unit)
                | Some (mouse_x, mouse_y) -> (
                    (* Check if cursor is outside map bounds *)
                    if mouse_x < 0. || mouse_x > Config.map_width || mouse_y < 0. || mouse_y > Config.map_height
                    then (
                      release_creet ();
                      Lwt.return_unit)
                    else Lwt.return_unit))))
end

module%client Counters = struct
  open Js_of_ocaml

  let healthy_counter_id = "healthy-counter"
  let sick_counter_id = "sick-counter"

  let update () =
    let creets : Creet.t list = !(State.active_creets) in
    let healthy_count =
      List.fold_left
        (fun acc (creet : Creet.t) ->
          if creet.status = Healthy then acc + 1 else acc)
        0 creets
    in
    let sick_count =
      List.fold_left
        (fun acc (creet : Creet.t) ->
          if creet.status <> Healthy then acc + 1 else acc)
        0 creets
    in
    let healthy_elem =
      Js.Opt.to_option
        (Dom_html.document##getElementById (Js.string healthy_counter_id))
    in
    let sick_elem =
      Js.Opt.to_option
        (Dom_html.document##getElementById (Js.string sick_counter_id))
    in
    match (healthy_elem, sick_elem) with
    | Some h, Some s ->
        h##.textContent :=
          Js.some (Js.string (string_of_int healthy_count));
        s##.textContent := Js.some (Js.string (string_of_int sick_count))
    | _ -> ()
end

module%client Game_loop = struct
  open Js_of_ocaml
  open Js_of_ocaml_lwt
  open Lwt.Infix

  let elapsed_time : float ref = ref 0.

  let min_x = 0.
  let min_y = 0.

  let clamp v low high =
    max low (min v high)

  let normalize dx dy =
    let mag = sqrt ((dx *. dx) +. (dy *. dy)) in
    if mag = 0. then (1., 0.) else (dx /. mag, dy /. mag)

  let reflect (creet : Creet.t) hit_x hit_y =
    if hit_x then creet.dir_x <- -.creet.dir_x;
    if hit_y then creet.dir_y <- -.creet.dir_y;
    let dir_x, dir_y = normalize creet.dir_x creet.dir_y in
    creet.dir_x <- dir_x;
    creet.dir_y <- dir_y

  let random_direction () =
    let angle = (Js.math##random) *. 2. *. 3.141592653589793 in
    normalize (cos angle) (sin angle)

  let should_turn (creet : Creet.t) =
    let threshold = Config.initial_chance +. (Config.step *. creet.time_since_last_change) in
    if threshold <= 0. then false
    else
      let clamped_threshold = min threshold Config.max_chance in
      let random_val = (Js.math##random) *. 100. in
      random_val < clamped_threshold

  let random_turn (creet : Creet.t) =
    let dir_x, dir_y = random_direction () in
    creet.dir_x <- dir_x;
    creet.dir_y <- dir_y;
    creet.time_since_last_change <- 0.

  let attempt_reproduction (creet : Creet.t) =
    if creet.status = Healthy then (
      creet.reproduction_timer <- creet.reproduction_timer +. Config.frame_duration;
      let rec loop () =
        if creet.reproduction_timer >= 1. then (
          creet.reproduction_timer <- creet.reproduction_timer -. 1.;
          let roll = (Js.math##random) *. 100. in
          if roll < Config.reproduction_chance then (
            let dir_x, dir_y = random_direction () in
            let spec =
              {
                id = State.fresh_id ();
                x = creet.x;
                y = creet.y;
                dir_x;
                dir_y;
                status = Healthy;
              }
            in
            ignore (State.spawn_spec spec));
          loop ())
      in
      loop ())
  let handle_bounds (creet : Creet.t) =
    let max_x_actual = Config.map_width -. creet.size in
    let max_y_actual = Config.map_height -. creet.size in
    let hit_left = creet.x <= min_x && creet.dir_x < 0. in
    let hit_right = creet.x >= max_x_actual && creet.dir_x > 0. in
    let hit_top = creet.y <= min_y && creet.dir_y < 0. in
    let hit_bottom = creet.y >= max_y_actual && creet.dir_y > 0. in
    let hit_x = hit_left || hit_right in
    let hit_y = hit_top || hit_bottom in
    if hit_x || hit_y then (
      reflect creet hit_x hit_y;
      if hit_top then Creet.become_sick creet;
      creet.x <- clamp creet.x min_x max_x_actual;
      creet.y <- clamp creet.y min_y max_y_actual)

  let creets_collide (creet1 : Creet.t) (creet2 : Creet.t) =
    let dx = creet2.x -. creet1.x in
    let dy = creet2.y -. creet1.y in
    let distance_squared = (dx *. dx) +. (dy *. dy) in
    let radius1 = creet1.size /. 2. in
    let radius2 = creet2.size /. 2. in
    let radius_sum = radius1 +. radius2 in
    let radius_sum_squared = radius_sum *. radius_sum in
    distance_squared <= radius_sum_squared

  let handle_collisions tree =
    List.iter
      (fun (sick_creet : Creet.t) ->
        if not sick_creet.grabbed then (
          let nearby = Quadtree.find_nearby sick_creet tree in
          List.iter
            (fun (other_creet : Creet.t) ->
              if
                other_creet.status = Healthy
                && not other_creet.grabbed
                && creets_collide sick_creet other_creet
              then (
                let roll = (Js.math##random) *. 100. in
                if roll < Config.infection_chance then Creet.become_sick other_creet))
            nearby))
      !(State.sick_creets)

  let find_closest_healthy_creet (creet : Creet.t) (tree : Quadtree.t) =
    let creet_center_x = creet.x +. (creet.size /. 2.) in
    let creet_center_y = creet.y +. (creet.size /. 2.) in
    let detection_radius_squared = Config.mean_detection_radius *. Config.mean_detection_radius in
    (* Use quadtree to find creets within detection radius *)
    let nearby_creets : Creet.t list =
      Quadtree.query_circle creet_center_x creet_center_y Config.mean_detection_radius tree
    in
    (* nearby_creets already contains only healthy creets; find closest *)
    let rec find_closest
        (best_creet : Creet.t option)
        (best_distance_squared : float)
        (remaining : Creet.t list) =
      match remaining with
      | [] -> best_creet
      | (other : Creet.t) :: rest ->
          let other_center_x = other.x +. (Config.creet_size /. 2.) in
          let other_center_y = other.y +. (Config.creet_size /. 2.) in
          let dx = other_center_x -. creet_center_x in
          let dy = other_center_y -. creet_center_y in
          let distance_squared = (dx *. dx) +. (dy *. dy) in
          if distance_squared <= detection_radius_squared
             && (best_creet = None || distance_squared < best_distance_squared)
          then find_closest (Some other) distance_squared rest
          else find_closest best_creet best_distance_squared rest
    in
    find_closest None 1e10 nearby_creets

  let advance (creet : Creet.t) (tree : Quadtree.t) =
    if creet.grabbed then (
      Creet.update_position creet)
    else (
      creet.time_since_last_change <- creet.time_since_last_change +. Config.frame_duration;
      (* Mean creets target closest healthy creet *)
      if creet.status = Mean then (
        match find_closest_healthy_creet creet tree with
        | None -> if should_turn creet then random_turn creet
        | Some target ->
            let creet_center_x = creet.x +. (creet.size /. 2.) in
            let creet_center_y = creet.y +. (creet.size /. 2.) in
            let target_center_x = target.x +. (target.size /. 2.) in
            let target_center_y = target.y +. (target.size /. 2.) in
            let dx = target_center_x -. creet_center_x in
            let dy = target_center_y -. creet_center_y in
            let dir_x, dir_y = normalize dx dy in
            creet.dir_x <- dir_x;
            creet.dir_y <- dir_y;
            creet.time_since_last_change <- 0.)
      else if should_turn creet then random_turn creet;
      attempt_reproduction creet;
      (* Grow berserk creets over time *)
      if creet.status = Berserk then (
        let max_size = Config.creet_size +. Config.berserk_extra_size in
        if creet.size < max_size then (
          creet.size <-
            min max_size
              (creet.size +. (Config.berserk_size_increment_per_second *. Config.frame_duration));
          Creet.update_size creet));
      let current_speed = Config.speed +. (Config.speed_increment_per_second *. !elapsed_time) in
      let step =
        current_speed
        *. (if creet.status <> Healthy then Config.sick_speed_modifier else 1.)
        *. Config.frame_duration
      in
      creet.x <- creet.x +. (creet.dir_x *. step);
      creet.y <- creet.y +. (creet.dir_y *. step);
      let max_x_actual = Config.map_width -. creet.size in
      let max_y_actual = Config.map_height -. creet.size in
      creet.x <- clamp creet.x min_x max_x_actual;
      creet.y <- clamp creet.y min_y max_y_actual;
      handle_bounds creet;
      Creet.update_position creet)

  let rec tick () =
    elapsed_time := !elapsed_time +. Config.frame_duration;
    (* Build quadtree with only healthy creets for targeting/infection *)
    let healthy_creets =
      List.filter (fun (c : Creet.t) -> c.status = Healthy) !(State.active_creets)
    in
    let tree = Quadtree.build healthy_creets in
    List.iter (fun creet -> advance creet tree) !(State.active_creets);
    handle_collisions tree;
    Counters.update ();
    Lwt_js.sleep Config.frame_duration >>= tick

  let start () = Lwt.async (fun () -> tick ())
end

module%client World = struct
  open Js_of_ocaml

  let root_id = "app-root"

  let get_root () =
    Js.Opt.to_option
      (Dom_html.document##getElementById (Js.string root_id))

  let mount () =
    match get_root () with
    | None -> ()
    | Some root ->
        let map = Map_canvas.create_empty () in
        Dom.appendChild root map;
        State.register_map map;
        Interaction.setup map;
        let shared_creets = ~%initial_creets in
        let next_id =
          List.fold_left (fun acc spec -> max acc spec.id) 0 shared_creets + 1
        in
        State.set_next_id next_id;
        let creets = List.map (fun spec -> Creet.spawn spec map) shared_creets in
        State.set_creets creets;
        Game_loop.start ()
end

let%client () =
  let open Js_of_ocaml in
  let handler _ =
    World.mount ();
    Js._false
  in
  Dom_html.window##.onload := Dom_html.handler handler

let%server main_service =
  Eliom_service.create ~path:(Eliom_service.Path [])
    ~meth:(Eliom_service.Get Eliom_parameter.unit) ()

let%client main_service = ~%main_service

let%shared () =
  App.register ~service:main_service (fun () () ->
    Lwt.return
      Html.(
        html
          (head
             (title (txt "Creet MVP"))
             [
               css_link
                 ~uri:
                   (make_uri
                      ~service:(Eliom_service.static_dir ())
                      ["css"; "creet_app.css"])
                 ();
             ])
          (body
             [
               h1 [txt "Creet MVP"];
               div
                 ~a:[
                   a_id "app-root";
                   a_class ["app-root"];
                   a_user_data
                     "creet-count"
                     (string_of_int (List.length initial_creets));
                 ]
                 [];
               div
                 ~a:[
                   a_id "healthy-counter";
                   a_class ["counter"; "counter--healthy"];
                 ]
                 [txt "0"];
               div
                 ~a:[
                   a_id "sick-counter";
                   a_class ["counter"; "counter--sick"];
                 ]
                 [txt "0"];
             ])))
