(* This file was generated by Eliom-distillery.
   Feel free to use it, modify it, and redistribute it as you wish. *)

let%server application_name = "creet_app"
let%client application_name = Eliom_client.get_application_name ()

module%shared Html = Eliom_content.Html.D

type%shared creet_status =
  | Healthy
  | Sick
  | Berserk
  | Mean

type%shared creet_spec = {
  id : int;
  x : float;
  y : float;
  dir_x : float;
  dir_y : float;
  status : creet_status;
} [@@ocaml.warning "-34"]


(* Create a module for the application. See
   https://ocsigen.org/eliom/manual/clientserver-applications for more
   information. *)
module%shared App = Eliom_registration.App (struct
    let application_name = application_name
    let global_data_path = Some ["__global_data__"]
  end)

(* As the headers (stylesheets, etc) won't change, we ask Eliom not to
   update the <head> of the page when changing page. (This also avoids
   blinking when changing page in iOS). *)
let%client _ = Eliom_client.persist_document_head ()

module%shared Constants = struct
  let initial_map_width = 420. [@@warning "-32"]
  let initial_map_height = 260. [@@warning "-32"]
  let initial_creet_size = 24.
  let initial_mean_size = 20.
  let creet_size_ratio = initial_creet_size /. initial_map_width [@@warning "-32"]
  let mean_size_ratio = initial_mean_size /. initial_map_width [@@warning "-32"]
end

module%client Config = struct
  (* Random direction change settings *)
  let initial_chance = -10.
  let step = 5.
  let max_chance = 40.
  let reproduction_chance = 5.
  
  (* Game loop settings *)
  let frame_duration = 0.02
  
  (* Movement settings (defaults) *)
  let speed = 60.
  let sick_speed_modifier = 0.85
  let speed_increment_per_second = 0.5
  
  (* Infection settings *)
  let infection_chance = 2.

end

module%client Game_time = struct
  let elapsed_time = ref 0.

  let reset () = elapsed_time := 0.
  let add dt = elapsed_time := !elapsed_time +. dt
  let get () = !elapsed_time
end

module%client Settings = struct
  let default_map_width = Constants.initial_map_width
  let default_map_height = Constants.initial_map_height
  let default_speed = Config.speed
  let default_sick_speed_modifier = Config.sick_speed_modifier
  let default_speed_increment = Config.speed_increment_per_second
  let default_berserk_chance = 10.
  let default_mean_chance = 10.
  let default_berserk_size_increment = 1.
  let default_initial_creet_count = 3

  let map_width = ref default_map_width
  let map_height = ref default_map_height
  let speed = ref default_speed
  let sick_speed_modifier = ref default_sick_speed_modifier
  let speed_increment = ref default_speed_increment
  let berserk_chance = ref default_berserk_chance
  let mean_chance = ref default_mean_chance
  let berserk_size_increment = ref default_berserk_size_increment
  let initial_creet_count = ref default_initial_creet_count

  let get_map_width () = !map_width
  let get_map_height () = !map_height
  let base_dimension () = min !map_width !map_height
  let sized_with_min ratio minimum =
    max minimum (base_dimension () *. ratio)
  let get_creet_size () =
    sized_with_min Constants.creet_size_ratio Constants.initial_creet_size
  let get_mean_size () =
    sized_with_min Constants.mean_size_ratio Constants.initial_mean_size
  let get_speed () = !speed
  let get_sick_speed_modifier () = !sick_speed_modifier
  let get_speed_increment_per_second () = !speed_increment
  let get_berserk_chance () = !berserk_chance
  let get_mean_chance () = !mean_chance
  let get_berserk_extra_size () = 3. *. get_creet_size ()
  let get_berserk_size_increment () = !berserk_size_increment
  let get_initial_creet_count () = !initial_creet_count

  let get_mean_detection_radius () = get_creet_size () *. 6.

  let get_healing_distance_threshold () =
    let base_creet = get_creet_size () in
    let mean_sz = get_mean_size () in
    let berserk_extra = get_berserk_extra_size () in
    let largest =
      max
        (berserk_extra +. base_creet)
        (berserk_extra +. mean_sz)
    in
    largest /. 9.

  let get_default_map_width () = default_map_width
  let get_default_map_height () = default_map_height
  let get_default_speed () = default_speed
  let get_default_sick_speed_modifier () = default_sick_speed_modifier
  let get_default_speed_increment () = default_speed_increment
  let get_default_berserk_chance () = default_berserk_chance
  let get_default_mean_chance () = default_mean_chance
  let get_default_berserk_size_increment () = default_berserk_size_increment
  let get_default_initial_creet_count () = default_initial_creet_count

  let set_map_width v = map_width := v
  let set_map_height v = map_height := v
  let set_speed v = speed := v
  let set_sick_speed_modifier v = sick_speed_modifier := v
  let set_speed_increment_per_second v = speed_increment := v
  let set_berserk_chance v = berserk_chance := v
  let set_mean_chance v = mean_chance := v
  let set_berserk_size_increment v = berserk_size_increment := v
  let set_initial_creet_count v = initial_creet_count := v

  let reset () =
    map_width := default_map_width;
    map_height := default_map_height;
    speed := default_speed;
    sick_speed_modifier := default_sick_speed_modifier;
    speed_increment := default_speed_increment;
    berserk_chance := default_berserk_chance;
    mean_chance := default_mean_chance;
    berserk_size_increment := default_berserk_size_increment;
    initial_creet_count := default_initial_creet_count
end

module%client Map_canvas = struct
  open Js_of_ocaml

  let map_id = "creet-map"

  let apply_dimensions container =
    container##.style##.width :=
      Js.string (Printf.sprintf "%gpx" (Settings.get_map_width ()));
    container##.style##.height :=
      Js.string (Printf.sprintf "%gpx" (Settings.get_map_height ()))

  let create_empty () =
    let container = Dom_html.createDiv Dom_html.document in
    container##.id := Js.string map_id;
    container##.className := Js.string "map-area";
    apply_dimensions container;
    container
end

module%client Creet = struct
  open Js_of_ocaml

  let normalize dx dy =
    let mag = sqrt ((dx *. dx) +. (dy *. dy)) in
    if mag = 0. then (1., 0.) else (dx /. mag, dy /. mag)

  type t = {
    spec : creet_spec;
    node : Dom_html.divElement Js.t;
    mutable x : float;
    mutable y : float;
    mutable dir_x : float;
    mutable dir_y : float;
    mutable time_since_last_change : float;
    mutable reproduction_timer : float;
    mutable status : creet_status;
    mutable grabbed : bool;
    mutable size : float;
    mutable running : bool;
    mutable custom_direction : (float * float) option;
  }

  let add_sick_creet_ref : (t -> unit) ref = ref (fun _ -> ())
  let remove_sick_creet_ref : (t -> unit) ref = ref (fun _ -> ())
  let add_healthy_creet_ref : (t -> unit) ref = ref (fun _ -> ())
  let remove_healthy_creet_ref : (t -> unit) ref = ref (fun _ -> ())

  let create_node (spec : creet_spec) =
    let node = Dom_html.createDiv Dom_html.document in
    node##.id := Js.string (Printf.sprintf "creet-%d" spec.id);
    node##.className := Js.string "creet";
    node##.style##.left := Js.string (Printf.sprintf "%gpx" spec.x);
    node##.style##.top := Js.string (Printf.sprintf "%gpx" spec.y);
    node

  let apply_status_style creet =
    let base_class =
      match creet.status with
      | Healthy -> "creet"
      | Sick -> "creet creet--sick"
      | Berserk -> "creet creet--sick creet--berserk"
      | Mean -> "creet creet--sick creet--mean"
    in
    let full_class =
      if creet.grabbed then base_class ^ " creet--grabbed" else base_class
    in
    creet.node##.className := Js.string full_class

  let update_size creet =
    creet.node##.style##.width := Js.string (Printf.sprintf "%gpx" creet.size);
    creet.node##.style##.height := Js.string (Printf.sprintf "%gpx" creet.size)

  let spawn (config : creet_spec) map_container =
    let node = create_node config in
    Dom.appendChild map_container node;
    let dir_x, dir_y = normalize config.dir_x config.dir_y in
    {
      spec = config;
      node;
      x = config.x;
      y = config.y;
      dir_x;
      dir_y;
      time_since_last_change = 0.;
      reproduction_timer = 0.;
      status = config.status;
      grabbed = false;
      size = Settings.get_creet_size ();
      running = false;
      custom_direction = None;
    }
    |> fun creet ->
    apply_status_style creet;
    update_size creet;
    creet

  let update_position creet =
    creet.node##.style##.left := Js.string (Printf.sprintf "%gpx" creet.x);
    creet.node##.style##.top := Js.string (Printf.sprintf "%gpx" creet.y)

  let become_sick creet =
    if creet.status = Healthy then (
      let berserk_chance = Settings.get_berserk_chance () in
      let mean_chance = Settings.get_mean_chance () in
      !remove_healthy_creet_ref creet;
      let roll = (Js.math##random) *. 100. in
      if roll < berserk_chance then (
        creet.status <- Berserk)
      else if roll < berserk_chance +. mean_chance then (
        creet.status <- Mean;
        creet.size <- Settings.get_mean_size ())
      else (
        creet.status <- Sick);
      apply_status_style creet;
      update_size creet;
      !add_sick_creet_ref creet)

  let become_healthy creet =
    if creet.status <> Healthy then (
      creet.status <- Healthy;
      creet.size <- Settings.get_creet_size ();
      apply_status_style creet;
      update_size creet;
      !add_healthy_creet_ref creet;
      !remove_sick_creet_ref creet)

  let set_grabbed creet grabbed =
    creet.grabbed <- grabbed;
    apply_status_style creet

end

module%client Creet_runner = struct
  open Js_of_ocaml_lwt
  open Lwt.Infix

  let get_healthy_creets_ref : (unit -> Creet.t list) ref = ref (fun () -> [])
  let spawn_spec_ref : (creet_spec -> unit) ref = ref (fun _ -> ())
  let fresh_id_ref : (unit -> int) ref = ref (fun () -> 0)

  let register_state_hooks ~get_healthy_creets ~spawn_spec ~fresh_id =
    get_healthy_creets_ref := get_healthy_creets;
    spawn_spec_ref := spawn_spec;
    fresh_id_ref := fresh_id

  let random_direction () =
    let angle = (Js_of_ocaml.Js.math##random) *. 2. *. 3.141592653589793 in
    Creet.normalize (cos angle) (sin angle)

  let should_turn (creet : Creet.t) =
    let threshold =
      Config.initial_chance +. (Config.step *. creet.time_since_last_change)
    in
    if threshold <= 0. then false
    else
      let clamped_threshold = min threshold Config.max_chance in
      let random_val = (Js_of_ocaml.Js.math##random) *. 100. in
      random_val < clamped_threshold

  let random_turn (creet : Creet.t) =
    let dir_x, dir_y = random_direction () in
    creet.dir_x <- dir_x;
    creet.dir_y <- dir_y;
    creet.time_since_last_change <- 0.

  let attempt_reproduction (creet : Creet.t) =
    if creet.status = Healthy then (
      creet.reproduction_timer <-
        creet.reproduction_timer +. Config.frame_duration;
      let rec loop () =
        if creet.reproduction_timer >= 1. then (
          creet.reproduction_timer <- creet.reproduction_timer -. 1.;
          let roll = (Js_of_ocaml.Js.math##random) *. 100. in
          if roll < Config.reproduction_chance then (
            let dir_x, dir_y = random_direction () in
            let spec =
              {
                id = (!fresh_id_ref) ();
                x = creet.x;
                y = creet.y;
                dir_x;
                dir_y;
                status = Healthy;
              }
            in
            (!spawn_spec_ref) spec);
          loop ())
      in
      loop ())

  let clamp v low high = max low (min v high)

  let handle_bounds (creet : Creet.t) =
    let max_x_actual = Settings.get_map_width () -. creet.size in
    let max_y_actual = Settings.get_map_height () -. creet.size in
    let hit_left = creet.x <= 0. && creet.dir_x < 0. in
    let hit_right = creet.x >= max_x_actual && creet.dir_x > 0. in
    let hit_top = creet.y <= 0. && creet.dir_y < 0. in
    let hit_bottom = creet.y >= max_y_actual && creet.dir_y > 0. in
    let hit_x = hit_left || hit_right in
    let hit_y = hit_top || hit_bottom in
    if hit_x then creet.dir_x <- -.creet.dir_x;
    if hit_y then creet.dir_y <- -.creet.dir_y;
    if hit_top then Creet.become_sick creet;
    creet.x <- clamp creet.x 0. max_x_actual;
    creet.y <- clamp creet.y 0. max_y_actual

  let update_mean_behavior (creet : Creet.t) =
    match creet.custom_direction with
    | Some (dir_x, dir_y) ->
        if dir_x = 0. && dir_y = 0. then (
          (* No target found, use normal wandering *)
          if should_turn creet then random_turn creet)
        else (
          (* Use quadtree-provided direction *)
          creet.dir_x <- dir_x;
          creet.dir_y <- dir_y;
          creet.time_since_last_change <- 0.;
          creet.custom_direction <- None)
    | None ->
        (* No custom direction set yet, use normal wandering *)
        if should_turn creet then random_turn creet

  let grow_berserk (creet : Creet.t) =
    if creet.status = Berserk then (
      let max_size =
        Settings.get_creet_size () +. Settings.get_berserk_extra_size ()
      in
      if creet.size < max_size then (
        let increment =
          Settings.get_berserk_size_increment () *. Config.frame_duration
        in
        creet.size <- min max_size (creet.size +. increment);
        Creet.update_size creet))

  let update_step (creet : Creet.t) =
    if creet.grabbed then
      Creet.update_position creet
    else (
      creet.time_since_last_change <-
        creet.time_since_last_change +. Config.frame_duration;
      (if creet.status = Mean then update_mean_behavior creet
      else if should_turn creet then random_turn creet);
      attempt_reproduction creet;
      grow_berserk creet;
      let speed_base = Settings.get_speed () in
      let speed_increment_per_second =
        Settings.get_speed_increment_per_second ()
      in
      let current_speed =
        speed_base +. (speed_increment_per_second *. Game_time.get ())
      in
      let step =
        current_speed
        *. (if creet.status <> Healthy then Settings.get_sick_speed_modifier ()
           else 1.)
        *. Config.frame_duration
      in
      creet.x <- creet.x +. (creet.dir_x *. step);
      creet.y <- creet.y +. (creet.dir_y *. step);
      handle_bounds creet;
      Creet.update_position creet)

  let rec loop (creet : Creet.t) =
    if creet.running then (
      update_step creet;
      Lwt_js.sleep Config.frame_duration >>= fun () -> loop creet)
    else Lwt.return_unit

  let start (creet : Creet.t) =
    if not creet.running then (
      creet.running <- true;
      Lwt.async (fun () -> loop creet))

  let stop (creet : Creet.t) = creet.running <- false
end

module%client Quadtree = struct
  type bounds = {
    x : float;
    y : float;
    width : float;
    height : float;
  }

  type t =
    | Empty
    | Leaf of { bounds : bounds; creets : Creet.t list }
    | Node of {
        bounds : bounds;
        nw : t;
        ne : t;
        sw : t;
        se : t;
      }

  let create_bounds x y width height = { x; y; width; height }

  let intersects bounds1 bounds2 =
    not
      (bounds1.x +. bounds1.width <= bounds2.x
      || bounds2.x +. bounds2.width <= bounds1.x
      || bounds1.y +. bounds1.height <= bounds2.y
      || bounds2.y +. bounds2.height <= bounds1.y)

  let get_creet_bounds (creet : Creet.t) : bounds =
    {
      x = creet.x;
      y = creet.y;
      width = creet.size;
      height = creet.size;
    }

  let max_objects = 4
  let max_depth = 6

  let subdivide bounds =
    let half_w = bounds.width /. 2. in
    let half_h = bounds.height /. 2. in
    let nw = create_bounds bounds.x bounds.y half_w half_h in
    let ne = create_bounds (bounds.x +. half_w) bounds.y half_w half_h in
    let sw = create_bounds bounds.x (bounds.y +. half_h) half_w half_h in
    let se =
      create_bounds (bounds.x +. half_w) (bounds.y +. half_h) half_w half_h
    in
    (nw, ne, sw, se)

  let rec insert (creet : Creet.t) bounds_param depth tree =
    let creet_bounds = get_creet_bounds creet in
    if not (intersects bounds_param creet_bounds) then tree
    else
      match tree with
      | Empty ->
          Leaf { bounds = bounds_param; creets = [ creet ] }
      | Leaf leaf ->
          if depth >= max_depth || List.length leaf.creets < max_objects then
            Leaf { bounds = bounds_param; creets = creet :: leaf.creets }
          else (
            let nw, ne, sw, se = subdivide bounds_param in
            let nw_tree = List.fold_left
                            (fun t c -> insert c nw (depth + 1) t)
                            Empty leaf.creets in
            let ne_tree = List.fold_left
                            (fun t c -> insert c ne (depth + 1) t)
                            Empty leaf.creets in
            let sw_tree = List.fold_left
                            (fun t c -> insert c sw (depth + 1) t)
                            Empty leaf.creets in
            let se_tree = List.fold_left
                            (fun t c -> insert c se (depth + 1) t)
                            Empty leaf.creets in
            insert creet bounds_param depth
              (Node {
                  bounds = bounds_param;
                  nw = nw_tree;
                  ne = ne_tree;
                  sw = sw_tree;
                  se = se_tree;
                }))
      | Node node ->
          let nw, ne, sw, se = subdivide bounds_param in
          Node
            {
              bounds = bounds_param;
              nw = insert creet nw (depth + 1) node.nw;
              ne = insert creet ne (depth + 1) node.ne;
              sw = insert creet sw (depth + 1) node.sw;
              se = insert creet se (depth + 1) node.se;
            }

  let rec query bounds tree acc =
    match tree with
    | Empty -> acc
    | Leaf leaf ->
        if intersects bounds leaf.bounds then
          List.fold_left
            (fun acc creet ->
              let creet_bounds = get_creet_bounds creet in
              if intersects bounds creet_bounds then creet :: acc else acc)
            acc leaf.creets
        else acc
    | Node node ->
        if intersects bounds node.bounds then
          query bounds node.nw acc
          |> query bounds node.ne
          |> query bounds node.sw
          |> query bounds node.se
        else acc

  let build creets =
    let bounds =
      create_bounds 0. 0. (Settings.get_map_width ()) (Settings.get_map_height ())
    in
    List.fold_left (fun tree creet -> insert creet bounds 0 tree) Empty creets

  let find_nearby creet tree =
    let creet_bounds = get_creet_bounds creet in
    query creet_bounds tree []

  let query_circle center_x center_y radius tree =
    let bounds =
      create_bounds
        (center_x -. radius)
        (center_y -. radius)
        (radius *. 2.)
        (radius *. 2.)
    in
    let candidates = query bounds tree [] in
    let radius_squared = radius *. radius in
    List.filter
      (fun (creet : Creet.t) ->
        let creet_center_x = creet.x +. (creet.size /. 2.) in
        let creet_center_y = creet.y +. (creet.size /. 2.) in
        let dx = creet_center_x -. center_x in
        let dy = creet_center_y -. center_y in
        let distance_squared = (dx *. dx) +. (dy *. dy) in
        distance_squared <= radius_squared)
      candidates

end

module%client State = struct
  open Js_of_ocaml
  let active_creets : Creet.t list ref = ref []
  let healthy_creets_table : (int, Creet.t) Hashtbl.t = Hashtbl.create 64
  let sick_creets_table : (int, Creet.t) Hashtbl.t = Hashtbl.create 64
  let map_container : Dom_html.divElement Js.t option ref = ref None
  let next_id = ref 0
  let on_no_healthy_ref : (unit -> unit) ref = ref (fun () -> ())

  let register_map map = map_container := Some map

  let add_to_table table (creet : Creet.t) =
    Hashtbl.replace table creet.spec.id creet

  let remove_from_table table (creet : Creet.t) =
    Hashtbl.remove table creet.spec.id

  let notify_if_no_healthy () =
    if Hashtbl.length healthy_creets_table = 0 then !on_no_healthy_ref ()

  let set_creets (creets : Creet.t list) =
    active_creets := creets;
    Hashtbl.reset healthy_creets_table;
    Hashtbl.reset sick_creets_table;
    List.iter
      (fun (c : Creet.t) ->
        if c.status = Healthy then add_to_table healthy_creets_table c
        else add_to_table sick_creets_table c)
      creets;
    List.iter Creet_runner.start creets;
    notify_if_no_healthy ()

  let clear_creets () =
    (match !map_container with
    | None -> ()
    | Some map ->
        List.iter
          (fun (creet : Creet.t) ->
            Creet_runner.stop creet;
            Dom.removeChild map (creet.node :> Dom.node Js.t))
          !active_creets);
    active_creets := [];
    Hashtbl.reset healthy_creets_table;
    Hashtbl.reset sick_creets_table

  let set_next_id value = next_id := value

  let fresh_id () =
    let id = !next_id in
    incr next_id;
    id

  let add_creet creet =
    active_creets := creet :: !active_creets;
    if creet.status = Healthy then add_to_table healthy_creets_table creet
    else add_to_table sick_creets_table creet;
    Creet_runner.start creet

  let add_sick_creet creet = add_to_table sick_creets_table creet

  let remove_sick_creet creet = remove_from_table sick_creets_table creet

  let add_healthy_creet creet = add_to_table healthy_creets_table creet

  let remove_healthy_creet creet =
    remove_from_table healthy_creets_table creet;
    notify_if_no_healthy ()

  let healthy_creets_list () =
    Hashtbl.fold (fun _ (c : Creet.t) acc -> c :: acc) healthy_creets_table []

  let healthy_creet_count () = Hashtbl.length healthy_creets_table

  let sick_creet_count () = Hashtbl.length sick_creets_table

  let iter_sick_creets f = Hashtbl.iter (fun _ creet -> f creet) sick_creets_table

  let () =
    Creet.add_sick_creet_ref := add_sick_creet;
    Creet.remove_sick_creet_ref := remove_sick_creet;
    Creet.add_healthy_creet_ref := add_healthy_creet;
    Creet.remove_healthy_creet_ref := remove_healthy_creet

  let set_on_no_healthy handler = on_no_healthy_ref := handler

  let spawn_spec spec =
    match !map_container with
    | None -> None
    | Some map ->
        let creet = Creet.spawn spec map in
        add_creet creet;
        Some creet

  let () =
    Creet_runner.register_state_hooks
      ~get_healthy_creets:healthy_creets_list
      ~spawn_spec:(fun spec -> ignore (spawn_spec spec))
      ~fresh_id:fresh_id
end

module%client Interaction = struct
  open Js_of_ocaml
  open Js_of_ocaml_lwt

  let grabbed_creet : Creet.t option ref = ref None
  let grab_offset : (float * float) option ref = ref None

  let get_map_position (ev : Dom_html.mouseEvent Js.t) =
    match !(State.map_container) with
    | None -> None
    | Some map ->
        let rect = map##getBoundingClientRect in
        let x = float_of_int ev##.clientX -. rect##.left in
        let y = float_of_int ev##.clientY -. rect##.top in
        Some (x, y)

  let clamp_to_bounds (creet : Creet.t) x y =
    let min_x = 0. in
    let min_y = 0. in
    let max_x = Settings.get_map_width () -. creet.size in
    let max_y = Settings.get_map_height () -. creet.size in
    let x = max min_x (min x max_x) in
    let y = max min_y (min y max_y) in
    (x, y)

  let check_and_heal_if_close_to_bottom (creet : Creet.t) =
    let bottom_wall_y = Settings.get_map_height () in
    let creet_bottom_y = creet.y +. creet.size in
    let distance_to_bottom = bottom_wall_y -. creet_bottom_y in
    if
      distance_to_bottom <= Settings.get_healing_distance_threshold ()
      && distance_to_bottom >= 0.
    then (
      if creet.status <> Healthy then
        Creet.become_healthy creet)

  let release_creet () =
    match !grabbed_creet with
    | None -> ()
    | Some creet ->
        Creet.set_grabbed creet false;
        check_and_heal_if_close_to_bottom creet;
        grabbed_creet := None;
        grab_offset := None;
        match !(State.map_container) with
        | None -> ()
        | Some map -> map##.classList##remove (Js.string "grabbing")

  let handle_click (ev : Dom_html.mouseEvent Js.t) =
    match get_map_position ev with
    | None -> ()
    | Some (x, y) -> (
        match !grabbed_creet with
        | Some _ -> release_creet ()
        | None -> (
          (* Use event target to find which element was clicked *)
          let clicked_element = Js.Opt.to_option ev##.target in
          match clicked_element with
          | None -> ()
          | Some element -> (
              (* Walk up the DOM tree to find an element with a creet ID *)
              let rec find_creet_id (el : Dom_html.element Js.t) =
                let id = Js.to_string el##.id in
                if String.length id > 6 && String.sub id 0 6 = "creet-" then (
                  try
                    let creet_id = int_of_string (String.sub id 6 (String.length id - 6)) in
                    Some creet_id
                  with _ -> None)
                else (
                  match Js.Opt.to_option el##.parentNode with
                  | None -> None
                  | Some parent_node -> (
                      try
                        let parent_el : Dom_html.element Js.t =
                          Js.Unsafe.coerce parent_node
                        in
                        find_creet_id parent_el
                      with _ -> None))
              in
              match find_creet_id element with
              | None -> ()
              | Some creet_id -> (
                  (* Find the Creet.t object with this ID *)
                  let creets = !(State.active_creets) in
                  let found_creet =
                    List.find_opt
                      (fun (creet : Creet.t) -> creet.spec.id = creet_id)
                      creets
                  in
                  match found_creet with
                  | None -> ()
                  | Some creet ->
                      if creet.status <> Healthy then (
                        let offset_x = x -. creet.x in
                        let offset_y = y -. creet.y in
                        grab_offset := Some (offset_x, offset_y);
                        Creet.set_grabbed creet true;
                        grabbed_creet := Some creet;
                        match !(State.map_container) with
                        | None -> ()
                        | Some map -> map##.classList##add (Js.string "grabbing"))
                      else ()))))

  let handle_mousemove (ev : Dom_html.mouseEvent Js.t) =
    match !grabbed_creet with
    | None -> ()
    | Some creet -> (
        match get_map_position ev with
        | None -> release_creet ()
        | Some (mouse_x, mouse_y) -> (
            (* Check if cursor is outside map bounds *)
            let map_width = Settings.get_map_width () in
            let map_height = Settings.get_map_height () in
            if mouse_x < 0. || mouse_x > map_width || mouse_y < 0. || mouse_y > map_height
            then release_creet ()
            else (
              match !grab_offset with
              | None -> release_creet ()
              | Some (offset_x, offset_y) ->
                  let x = mouse_x -. offset_x in
                  let y = mouse_y -. offset_y in
                  let x, y = clamp_to_bounds creet x y in
                  creet.x <- x;
                  creet.y <- y;
                  Creet.update_position creet)))

  let setup map =
    let map_element = (map :> Dom_html.element Js.t) in
    Lwt.async (fun () ->
        Lwt_js_events.mousedowns map_element (fun ev _ ->
            handle_click ev;
            Lwt.return_unit));
    Lwt.async (fun () ->
        Lwt_js_events.mousemoves map_element (fun ev _ ->
            handle_mousemove ev;
            Lwt.return_unit));
    (* Also listen to document-level mousemove to catch fast movements outside map *)
    Lwt.async (fun () ->
        Lwt_js_events.mousemoves Dom_html.document##.documentElement (fun ev _ ->
            match !grabbed_creet with
            | None -> Lwt.return_unit
            | Some _ -> (
                match get_map_position ev with
                | None -> (
                    release_creet ();
                    Lwt.return_unit)
                | Some (mouse_x, mouse_y) -> (
                    (* Check if cursor is outside map bounds *)
                    let map_width = Settings.get_map_width () in
                    let map_height = Settings.get_map_height () in
                    if mouse_x < 0. || mouse_x > map_width || mouse_y < 0. || mouse_y > map_height
                    then (
                      release_creet ();
                      Lwt.return_unit)
                    else Lwt.return_unit))))
  let force_release_grab () = release_creet ()
end

module%client Counters = struct
  open Js_of_ocaml

  let healthy_counter_id = "healthy-counter"
  let sick_counter_id = "sick-counter"
  let time_counter_id = "time-counter"
  let speed_counter_id = "speed-counter"

  let update ~elapsed_time ~speed_increment =
    let healthy_count = State.healthy_creet_count () in
    let sick_count = State.sick_creet_count () in
    let healthy_elem =
      Js.Opt.to_option
        (Dom_html.document##getElementById (Js.string healthy_counter_id))
    in
    let sick_elem =
      Js.Opt.to_option
        (Dom_html.document##getElementById (Js.string sick_counter_id))
    in
    let time_elem =
      Js.Opt.to_option
        (Dom_html.document##getElementById (Js.string time_counter_id))
    in
    let speed_elem =
      Js.Opt.to_option
        (Dom_html.document##getElementById (Js.string speed_counter_id))
    in
    (match (healthy_elem, sick_elem) with
    | Some h, Some s ->
        h##.textContent :=
          Js.some (Js.string (string_of_int healthy_count));
        s##.textContent := Js.some (Js.string (string_of_int sick_count))
    | _ -> ());
    (match time_elem with
    | Some t ->
        let text = Js.string (Printf.sprintf "%.1fs" elapsed_time) in
        t##.textContent := Js.some text
    | None -> ());
    (match speed_elem with
    | Some sp ->
        let text =
          Js.string
            (Printf.sprintf "+%.2f" speed_increment)
        in
        sp##.textContent := Js.some text
    | None -> ())
end

module%client Game_loop = struct
  open Js_of_ocaml
  open Js_of_ocaml_lwt
  open Lwt.Infix

  let creets_collide (creet1 : Creet.t) (creet2 : Creet.t) =
    let dx = creet2.x -. creet1.x in
    let dy = creet2.y -. creet1.y in
    let distance_squared = (dx *. dx) +. (dy *. dy) in
    let radius1 = creet1.size /. 2. in
    let radius2 = creet2.size /. 2. in
    let radius_sum = radius1 +. radius2 in
    let radius_sum_squared = radius_sum *. radius_sum in
    distance_squared <= radius_sum_squared

  let handle_collisions tree =
    State.iter_sick_creets
      (fun (sick_creet : Creet.t) ->
        if not sick_creet.grabbed then (
          (* Handle mean creet targeting *)
          if sick_creet.status = Mean then (
            let creet_center_x = sick_creet.x +. (sick_creet.size /. 2.) in
            let creet_center_y = sick_creet.y +. (sick_creet.size /. 2.) in
            let detection_radius = Settings.get_mean_detection_radius () in
            let nearby_healthy = Quadtree.query_circle creet_center_x creet_center_y detection_radius tree in
            match nearby_healthy with
            | [] -> sick_creet.custom_direction <- Some (0., 0.)
            | healthy_creets ->
                let best_target, best_center, _ =
                  List.fold_left
                    (fun (best, best_center, best_dist) (target : Creet.t) ->
                      let target_center_x = target.x +. (target.size /. 2.) in
                      let target_center_y = target.y +. (target.size /. 2.) in
                      let dx = target_center_x -. creet_center_x in
                      let dy = target_center_y -. creet_center_y in
                      let distance_squared = (dx *. dx) +. (dy *. dy) in
                      if best = None || distance_squared < best_dist then
                        (Some target, Some (target_center_x, target_center_y), distance_squared)
                      else (best, best_center, best_dist))
                    (None, None, detection_radius *. detection_radius)
                    healthy_creets
                in
                match (best_target, best_center) with
                | None, _ | _, None -> sick_creet.custom_direction <- Some (0., 0.)
                | Some _, Some (target_center_x, target_center_y) ->
                    let dx = target_center_x -. creet_center_x in
                    let dy = target_center_y -. creet_center_y in
                    let dir_x, dir_y = Creet.normalize dx dy in
                    sick_creet.custom_direction <- Some (dir_x, dir_y));
          (* Handle collision-based infection *)
          let nearby = Quadtree.find_nearby sick_creet tree in
          List.iter
            (fun (other_creet : Creet.t) ->
              if creets_collide sick_creet other_creet then (
                let roll = (Js.math##random) *. 100. in
                if roll < Config.infection_chance then Creet.become_sick other_creet))
            nearby))

  let rec tick () =
    Game_time.add Config.frame_duration;
    let tree = Quadtree.build (State.healthy_creets_list ()) in
    handle_collisions tree;
    let elapsed = Game_time.get () in
    let speed_increment =
      Settings.get_speed_increment_per_second () *. elapsed
    in
    Counters.update ~elapsed_time:elapsed ~speed_increment;
    Lwt_js.sleep Config.frame_duration >>= tick

  let start () = Lwt.async (fun () -> tick ())
end

module%client World = struct
  open Js_of_ocaml

  let root_id = "app-root"
  let started = ref false

  let spawn_initial_creets map =
    let count = Settings.get_initial_creet_count () in
    let map_width = Settings.get_map_width () in
    let map_height = Settings.get_map_height () in
    let creet_size = Settings.get_creet_size () in
    let max_x = map_width -. creet_size in
    let max_y = map_height -. creet_size in
    let next_id = ref 1 in
    let generate_random_creet () =
      let x = (Js.math##random) *. max_x in
      let y = (Js.math##random) *. max_y in
      let angle = (Js.math##random) *. 2. *. 3.141592653589793 in
      let dir_x = cos angle in
      let dir_y = sin angle in
      let id = !next_id in
      incr next_id;
      { id; x; y; dir_x; dir_y; status = Healthy }
    in
    let rec generate_creets n acc =
      if n <= 0 then acc
      else generate_creets (n - 1) (generate_random_creet () :: acc)
    in
    let creet_specs = generate_creets count [] in
    let creets = List.map (fun spec -> Creet.spawn spec map) creet_specs in
    State.set_creets creets;
    State.set_next_id (count + 1)

  let get_root () =
    Js.Opt.to_option
      (Dom_html.document##getElementById (Js.string root_id))

  let reset_creets () =
    match !(State.map_container) with
    | None -> ()
    | Some map ->
        Interaction.force_release_grab ();
        State.clear_creets ();
        Map_canvas.apply_dimensions map;
        spawn_initial_creets map

  let mount () =
    if !started then ()
    else (
      started := true;
      match get_root () with
      | None -> ()
      | Some root ->
          let map = Map_canvas.create_empty () in
          Dom.appendChild root map;
          State.register_map map;
          Interaction.setup map;
          spawn_initial_creets map;
          Game_loop.start ();
    )
end

module%client Menu = struct
  open Js_of_ocaml

  let menu_id = "menu-screen"
  let game_ui_id = "game-ui"
  let game_over_id = "game-over-screen"
  let game_over_time_id = "game-over-time"
  let width_input_id = "map-width-input"
  let height_input_id = "map-height-input"
  let speed_input_id = "speed-input"
  let sick_speed_input_id = "sick-speed-input"
  let speed_increment_input_id = "speed-increment-input"
  let berserk_chance_input_id = "berserk-chance-input"
  let mean_chance_input_id = "mean-chance-input"
  let berserk_increment_input_id = "berserk-size-increment-input"
  let initial_creet_count_input_id = "initial-creet-count-input"
  let play_button_id = "play-button"
  let reset_button_id = "reset-button"
  let go_to_menu_button_id = "go-to-menu-button"

  let get_element id =
    Js.Opt.to_option
      (Dom_html.document##getElementById (Js.string id))

  let get_input id =
    match get_element id with
    | None -> None
    | Some el -> Js.Opt.to_option (Dom_html.CoerceTo.input el)

  let set_input_attribute input name value =
    ignore (input##setAttribute (Js.string name) (Js.string value))

  let configure_inputs () =
    (match get_input width_input_id with
    | Some input ->
        set_input_attribute input "min" "100";
        set_input_attribute input "step" "10"
    | None -> ());
    (match get_input height_input_id with
    | Some input ->
        set_input_attribute input "min" "100";
        set_input_attribute input "step" "10"
    | None -> ());
    (match get_input speed_input_id with
    | Some input ->
        set_input_attribute input "min" "1";
        set_input_attribute input "step" "1"
    | None -> ());
    (match get_input sick_speed_input_id with
    | Some input ->
        set_input_attribute input "min" "0.1";
        set_input_attribute input "max" "1";
        set_input_attribute input "step" "0.01"
    | None -> ());
    (match get_input speed_increment_input_id with
    | Some input ->
        set_input_attribute input "min" "0";
        set_input_attribute input "step" "0.1"
    | None -> ());
    (match get_input berserk_chance_input_id with
    | Some input ->
        set_input_attribute input "min" "0";
        set_input_attribute input "max" "100";
        set_input_attribute input "step" "1"
    | None -> ());
    (match get_input mean_chance_input_id with
    | Some input ->
        set_input_attribute input "min" "0";
        set_input_attribute input "max" "100";
        set_input_attribute input "step" "1"
    | None -> ());
    (match get_input berserk_increment_input_id with
    | Some input ->
        set_input_attribute input "min" "0.01";
        set_input_attribute input "step" "0.1"
    | None -> ());
    (match get_input initial_creet_count_input_id with
    | Some input ->
        set_input_attribute input "min" "1";
        set_input_attribute input "step" "1"
    | None -> ())

  let set_hidden id hidden =
    match get_element id with
    | None -> ()
    | Some el ->
        let cls = Js.string "hidden" in
        if hidden then ignore (el##.classList##add cls)
        else ignore (el##.classList##remove cls)

  let show_menu () = set_hidden menu_id false
  let hide_menu () = set_hidden menu_id true
  let show_game_ui () = set_hidden game_ui_id false
  let hide_game_ui () = set_hidden game_ui_id true
  let show_game_over () = set_hidden game_over_id false
  let hide_game_over () = set_hidden game_over_id true

  let update_game_over_time elapsed =
    match get_element game_over_time_id with
    | None -> ()
    | Some el ->
        let text = Printf.sprintf "Elapsed time: %.1fs" elapsed in
        el##.textContent := Js.some (Js.string text)

  let show_game_over_screen elapsed =
    hide_menu ();
    hide_game_ui ();
    update_game_over_time elapsed;
    show_game_over ()

  let format_float value =
    let fractional = abs_float (value -. floor value) in
    if fractional < 0.001 then Printf.sprintf "%.0f" value
    else Printf.sprintf "%.2f" value

  let set_input_value id value =
    match get_input id with
    | Some input -> input##.value := Js.string (format_float value)
    | None -> ()

  let set_int_input_value id value =
    match get_input id with
    | Some input -> input##.value := Js.string (string_of_int value)
    | None -> ()

  let clamp value min_value max_value =
    let v = if value < min_value then min_value else value in
    match max_value with
    | None -> v
    | Some max_v -> if v > max_v then max_v else v

  let parse_float_with_limits id ~default ~min_value ~max_value =
    match get_input id with
    | None -> default
    | Some input ->
        let raw = Js.to_string input##.value in
        try
          let v = float_of_string raw in
          clamp v min_value max_value
        with _ -> default

  let parse_dimension id default =
    parse_float_with_limits id ~default ~min_value:100. ~max_value:None

  let parse_range id default ~min_value ~max_value =
    parse_float_with_limits id ~default ~min_value ~max_value:(Some max_value)

  let parse_percentage id default =
    parse_float_with_limits id ~default ~min_value:0. ~max_value:(Some 100.)

  let parse_int_with_limits id ~default ~min_value ~max_value =
    match get_input id with
    | None -> default
    | Some input ->
        let raw = Js.to_string input##.value in
        try
          let v = int_of_string raw in
          let v = max min_value v in
          match max_value with None -> v | Some max_v -> min v max_v
        with _ -> default

  let handle_reset _ =
    Settings.reset ();
    set_input_value width_input_id (Settings.get_default_map_width ());
    set_input_value height_input_id (Settings.get_default_map_height ());
    set_input_value speed_input_id (Settings.get_default_speed ());
    set_input_value sick_speed_input_id (Settings.get_default_sick_speed_modifier ());
    set_input_value speed_increment_input_id (Settings.get_default_speed_increment ());
    set_input_value berserk_chance_input_id (Settings.get_default_berserk_chance ());
    set_input_value mean_chance_input_id (Settings.get_default_mean_chance ());
    set_input_value berserk_increment_input_id (Settings.get_default_berserk_size_increment ());
    set_int_input_value initial_creet_count_input_id (Settings.get_default_initial_creet_count ());
    Js._false

  let handle_go_to_menu _ =
    hide_game_over ();
    hide_game_ui ();
    show_menu ();
    Game_time.reset ();
    Counters.update ~elapsed_time:0. ~speed_increment:0.;
    Js._false

  let handle_play _ =
    let width = parse_dimension width_input_id (Settings.get_map_width ()) in
    let height =
      parse_dimension height_input_id (Settings.get_map_height ())
    in
    let speed =
      parse_float_with_limits speed_input_id
        ~default:(Settings.get_speed ()) ~min_value:1. ~max_value:None
    in
    let sick_modifier =
      parse_range sick_speed_input_id (Settings.get_sick_speed_modifier ())
        ~min_value:0.1 ~max_value:1.
    in
    let speed_increment =
      parse_float_with_limits speed_increment_input_id
        ~default:(Settings.get_speed_increment_per_second ()) ~min_value:0.
        ~max_value:None
    in
    let berserk_chance =
      parse_percentage berserk_chance_input_id (Settings.get_berserk_chance ())
    in
    let mean_chance =
      parse_percentage mean_chance_input_id (Settings.get_mean_chance ())
    in
    let berserk_increment =
      parse_float_with_limits berserk_increment_input_id
        ~default:(Settings.get_berserk_size_increment ()) ~min_value:0.01
        ~max_value:None
    in
    let initial_creet_count =
      parse_int_with_limits initial_creet_count_input_id
        ~default:(Settings.get_initial_creet_count ()) ~min_value:1 ~max_value:None
    in
    Settings.set_map_width width;
    Settings.set_map_height height;
    Settings.set_speed speed;
    Settings.set_sick_speed_modifier sick_modifier;
    Settings.set_speed_increment_per_second speed_increment;
    Settings.set_berserk_chance berserk_chance;
    Settings.set_mean_chance mean_chance;
    Settings.set_berserk_size_increment berserk_increment;
    Settings.set_initial_creet_count initial_creet_count;
    hide_game_over ();
    World.mount ();
    World.reset_creets ();
    hide_menu ();
    show_game_ui ();
    Game_time.reset ();
    Counters.update ~elapsed_time:0. ~speed_increment:0.;
    Js._false

  let attach_click id handler =
    match get_element id with
    | None -> ()
    | Some el ->
        ignore
          (Dom_html.addEventListener el Dom_html.Event.click
             (Dom_html.handler handler) Js._false)

  let init () =
    configure_inputs ();
    set_input_value width_input_id (Settings.get_map_width ());
    set_input_value height_input_id (Settings.get_map_height ());
    set_input_value speed_input_id (Settings.get_speed ());
    set_input_value sick_speed_input_id (Settings.get_sick_speed_modifier ());
    set_input_value speed_increment_input_id
      (Settings.get_speed_increment_per_second ());
    set_input_value berserk_chance_input_id (Settings.get_berserk_chance ());
    set_input_value mean_chance_input_id (Settings.get_mean_chance ());
    set_input_value berserk_increment_input_id (Settings.get_berserk_size_increment ());
    set_int_input_value initial_creet_count_input_id (Settings.get_initial_creet_count ());
    attach_click play_button_id handle_play;
    attach_click reset_button_id handle_reset;
    attach_click go_to_menu_button_id handle_go_to_menu
end

module%client Game_over_screen = struct
  let handle_no_healthy () =
    let elapsed = Game_time.get () in
    Menu.show_game_over_screen elapsed

  let () = State.set_on_no_healthy handle_no_healthy
end

let%client () =
  let open Js_of_ocaml in
  let handler _ =
    Menu.init ();
    Js._false
  in
  Dom_html.window##.onload := Dom_html.handler handler

let%server main_service =
  Eliom_service.create ~path:(Eliom_service.Path [])
    ~meth:(Eliom_service.Get Eliom_parameter.unit) ()

let%client main_service = ~%main_service

let%shared () =
  App.register ~service:main_service (fun () () ->
    Lwt.return
      Html.(
        html
          (head
             (title (txt "Creet MVP"))
             [
               css_link
                 ~uri:
                   (make_uri
                      ~service:(Eliom_service.static_dir ())
                      ["css"; "creet_app.css"])
                 ();
             ])
          (body
             [
               h1 [txt "Creet MVP"];
              div
                ~a:[a_id "menu-screen"; a_class ["menu-screen"]]
                [
                  h2 [txt "Settings"];
                  div
                    ~a:[a_class ["menu__section"]]
                    [
                      h3 [txt "Map"];
                      div
                        ~a:[a_class ["menu__group"]]
                        [
                          label ~a:[a_label_for "map-width-input"] [txt "Map width (px)"];
                          input
                            ~a:[
                              a_id "map-width-input";
                              a_input_type `Number;
                            ]
                            ();
                        ];
                      div
                        ~a:[a_class ["menu__group"]]
                        [
                          label ~a:[a_label_for "map-height-input"] [txt "Map height (px)"];
                          input
                            ~a:[
                              a_id "map-height-input";
                              a_input_type `Number;
                            ]
                            ();
                        ];
                    ];
                  div
                    ~a:[a_class ["menu__section"]]
                    [
                      h3 [txt "Movement"];
                      div
                        ~a:[a_class ["menu__group"]]
                        [
                          label ~a:[a_label_for "speed-input"] [txt "Base speed"];
                          input
                            ~a:[
                              a_id "speed-input";
                              a_input_type `Number;
                            ]
                            ();
                        ];
                      div
                        ~a:[a_class ["menu__group"]]
                        [
                          label ~a:[a_label_for "sick-speed-input"] [txt "Sick speed modifier (0.1 - 1.0)"];
                          input
                            ~a:[
                              a_id "sick-speed-input";
                              a_input_type `Range;
                            ]
                            ();
                        ];
                      div
                        ~a:[a_class ["menu__group"]]
                        [
                          label ~a:[a_label_for "berserk-chance-input"] [txt "Berserk chance (%)"];
                          input
                            ~a:[
                              a_id "berserk-chance-input";
                              a_input_type `Range;
                            ]
                            ();
                        ];
                      div
                        ~a:[a_class ["menu__group"]]
                        [
                          label ~a:[a_label_for "mean-chance-input"] [txt "Mean chance (%)"];
                          input
                            ~a:[
                              a_id "mean-chance-input";
                              a_input_type `Range;
                            ]
                            ();
                        ];
                      div
                        ~a:[a_class ["menu__group"]]
                        [
                          label ~a:[a_label_for "berserk-size-increment-input"] [txt "Berserk size increment / s"];
                          input
                            ~a:[
                              a_id "berserk-size-increment-input";
                              a_input_type `Number;
                            ]
                            ();
                        ];
                      div
                        ~a:[a_class ["menu__group"]]
                        [
                          label ~a:[a_label_for "speed-increment-input"] [txt "Speed increment per second"];
                          input
                            ~a:[
                              a_id "speed-increment-input";
                              a_input_type `Number;
                            ]
                            ();
                        ];
                      div
                        ~a:[a_class ["menu__group"]]
                        [
                          label ~a:[a_label_for "initial-creet-count-input"] [txt "Initial creet count"];
                          input
                            ~a:[
                              a_id "initial-creet-count-input";
                              a_input_type `Number;
                            ]
                            ();
                        ];
                    ];
                  div
                    ~a:[a_class ["menu__actions"]]
                    [
                      button ~a:[a_id "reset-button"; a_class ["menu__button"]] [txt "Reset"];
                      button ~a:[a_id "play-button"; a_class ["menu__button"; "menu__button--primary"]] [txt "Play"];
                    ];
                ];
               div
                 ~a:[a_id "game-ui"; a_class ["game-ui"; "hidden"]]
                 [
                   div
                     ~a:[
                       a_id "app-root";
                       a_class ["app-root"];
                     ]
                     [];
                   div
                     ~a:[
                       a_id "healthy-counter";
                       a_class ["counter"; "counter--healthy"];
                     ]
                     [txt "0"];
                   div
                     ~a:[
                       a_id "sick-counter";
                       a_class ["counter"; "counter--sick"];
                     ]
                     [txt "0"];
                   div
                     ~a:[
                       a_id "time-counter";
                       a_class ["counter"; "counter--time"];
                     ]
                     [txt "0s"];
                   div
                     ~a:[
                       a_id "speed-counter";
                       a_class ["counter"; "counter--speed"];
                     ]
                    [txt "+0.00"];
                 ];
              div
                ~a:[a_id "game-over-screen"; a_class ["game-over"; "hidden"]]
                [
                  h2 [txt "Game Over"];
                  p
                    ~a:[a_id "game-over-time"; a_class ["game-over__time"]]
                    [txt "Elapsed time: 0s"];
                  button
                    ~a:[
                      a_id "go-to-menu-button";
                      a_class ["menu__button"; "menu__button--primary"];
                    ]
                    [txt "Go to menu"];
                ];
             ])))
