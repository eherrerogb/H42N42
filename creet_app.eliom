(* This file was generated by Eliom-distillery.
   Feel free to use it, modify it, and redistribute it as you wish. *)

let%server application_name = "creet_app"
let%client application_name = Eliom_client.get_application_name ()

module%shared Html = Eliom_content.Html.D

type%shared creet_status =
  | Healthy
  | Sick
  | Berserk
  | Mean

type%shared creet_spec = {
  id : int;
  x : float;
  y : float;
  dir_x : float;
  dir_y : float;
  status : creet_status;
}

let%shared initial_creets =
  [
    { id = 1; x = 40.; y = 60.; dir_x = 1.; dir_y = 0.3; status = Healthy };
    { id = 2; x = 160.; y = 140.; dir_x = -0.6; dir_y = 0.9; status = Healthy };
    { id = 3; x = 280.; y = 90.; dir_x = 0.2; dir_y = -1.; status = Healthy };
  ]

(* Create a module for the application. See
   https://ocsigen.org/eliom/manual/clientserver-applications for more
   information. *)
module%shared App = Eliom_registration.App (struct
    let application_name = application_name
    let global_data_path = Some ["__global_data__"]
  end)

(* As the headers (stylesheets, etc) won't change, we ask Eliom not to
   update the <head> of the page when changing page. (This also avoids
   blinking when changing page in iOS). *)
let%client _ = Eliom_client.persist_document_head ()

module%shared Constants = struct
  let initial_map_width = 420. [@@warning "-32"]
  let initial_map_height = 260. [@@warning "-32"]
  let initial_creet_size = 24.
  let initial_mean_size = 20.
  let initial_berserk_extra_size = 72.
  let creet_size_ratio = initial_creet_size /. initial_map_width [@@warning "-32"]
  let mean_size_ratio = initial_mean_size /. initial_map_width [@@warning "-32"]
  let berserk_extra_ratio =
    initial_berserk_extra_size /. initial_map_width [@@warning "-32"]
end

module%client Config = struct
  (* Random direction change settings *)
  let initial_chance = -10.
  let step = 5.
  let max_chance = 40.
  let reproduction_chance = 5.
  
  (* Game loop settings *)
  let frame_duration = 0.02
  
  (* Movement settings (defaults) *)
  let speed = 60.
  let sick_speed_modifier = 0.85
  let speed_increment_per_second = 0.5
  
  (* Infection settings *)
  let infection_chance = 2.

end

module%client Settings = struct
  let default_map_width = Constants.initial_map_width
  let default_map_height = Constants.initial_map_height
  let default_speed = Config.speed
  let default_sick_speed_modifier = Config.sick_speed_modifier
  let default_speed_increment = Config.speed_increment_per_second
  let default_berserk_chance = 10.
  let default_mean_chance = 10.
  let default_berserk_size_increment = 1.

  let map_width = ref default_map_width
  let map_height = ref default_map_height
  let speed = ref default_speed
  let sick_speed_modifier = ref default_sick_speed_modifier
  let speed_increment = ref default_speed_increment
  let berserk_chance = ref default_berserk_chance
  let mean_chance = ref default_mean_chance
  let berserk_size_increment = ref default_berserk_size_increment

  let get_map_width () = !map_width
  let get_map_height () = !map_height
  let get_creet_size () = get_map_width () *. Constants.creet_size_ratio
  let get_mean_size () = get_map_width () *. Constants.mean_size_ratio
  let get_speed () = !speed
  let get_sick_speed_modifier () = !sick_speed_modifier
  let get_speed_increment_per_second () = !speed_increment
  let get_berserk_chance () = !berserk_chance
  let get_mean_chance () = !mean_chance
  let get_berserk_extra_size () =
    get_map_width () *. Constants.berserk_extra_ratio
  let get_berserk_size_increment () = !berserk_size_increment

  let get_mean_detection_radius () = get_creet_size () *. 6.

  let get_healing_distance_threshold () =
    let base_creet = get_creet_size () in
    let mean_sz = get_mean_size () in
    let berserk_extra = get_berserk_extra_size () in
    let largest =
      max
        (berserk_extra +. base_creet)
        (berserk_extra +. mean_sz)
    in
    largest /. 9.

  let get_default_map_width () = default_map_width
  let get_default_map_height () = default_map_height
  let get_default_speed () = default_speed
  let get_default_sick_speed_modifier () = default_sick_speed_modifier
  let get_default_speed_increment () = default_speed_increment
  let get_default_berserk_chance () = default_berserk_chance
  let get_default_mean_chance () = default_mean_chance
  let get_default_berserk_size_increment () = default_berserk_size_increment

  let set_map_width v = map_width := v
  let set_map_height v = map_height := v
  let set_speed v = speed := v
  let set_sick_speed_modifier v = sick_speed_modifier := v
  let set_speed_increment_per_second v = speed_increment := v
  let set_berserk_chance v = berserk_chance := v
  let set_mean_chance v = mean_chance := v
  let set_berserk_size_increment v = berserk_size_increment := v

  let reset () =
    map_width := default_map_width;
    map_height := default_map_height;
    speed := default_speed;
    sick_speed_modifier := default_sick_speed_modifier;
    speed_increment := default_speed_increment;
    berserk_chance := default_berserk_chance;
    mean_chance := default_mean_chance;
    berserk_size_increment := default_berserk_size_increment
end

module%client Map_canvas = struct
  open Js_of_ocaml

  let map_id = "creet-map"

  let create_empty () =
    let container = Dom_html.createDiv Dom_html.document in
    container##.id := Js.string map_id;
    container##.className := Js.string "map-area";
    container##.style##.width :=
      Js.string (Printf.sprintf "%gpx" (Settings.get_map_width ()));
    container##.style##.height :=
      Js.string (Printf.sprintf "%gpx" (Settings.get_map_height ()));
    container
end

module%client Creet = struct
  open Js_of_ocaml

  let normalize dx dy =
    let mag = sqrt ((dx *. dx) +. (dy *. dy)) in
    if mag = 0. then (1., 0.) else (dx /. mag, dy /. mag)

  type t = {
    spec : creet_spec;
    node : Dom_html.divElement Js.t;
    mutable x : float;
    mutable y : float;
    mutable dir_x : float;
    mutable dir_y : float;
    mutable time_since_last_change : float;
    mutable reproduction_timer : float;
    mutable status : creet_status;
    mutable grabbed : bool;
    mutable size : float;
  }

  let add_sick_creet_ref : (t -> unit) ref = ref (fun _ -> ())
  let remove_sick_creet_ref : (t -> unit) ref = ref (fun _ -> ())
  let add_healthy_creet_ref : (t -> unit) ref = ref (fun _ -> ())
  let remove_healthy_creet_ref : (t -> unit) ref = ref (fun _ -> ())

  let create_node (spec : creet_spec) =
    let node = Dom_html.createDiv Dom_html.document in
    node##.id := Js.string (Printf.sprintf "creet-%d" spec.id);
    node##.className := Js.string "creet";
    node##.style##.left := Js.string (Printf.sprintf "%gpx" spec.x);
    node##.style##.top := Js.string (Printf.sprintf "%gpx" spec.y);
    node

  let apply_status_style creet =
    let base_class =
      match creet.status with
      | Healthy -> "creet"
      | Sick -> "creet creet--sick"
      | Berserk -> "creet creet--sick creet--berserk"
      | Mean -> "creet creet--sick creet--mean"
    in
    let full_class =
      if creet.grabbed then base_class ^ " creet--grabbed" else base_class
    in
    creet.node##.className := Js.string full_class

  let update_size creet =
    creet.node##.style##.width := Js.string (Printf.sprintf "%gpx" creet.size);
    creet.node##.style##.height := Js.string (Printf.sprintf "%gpx" creet.size)

  let spawn (config : creet_spec) map_container =
    let node = create_node config in
    node##.style##.left := Js.string (Printf.sprintf "%gpx" config.x);
    node##.style##.top := Js.string (Printf.sprintf "%gpx" config.y);
    Dom.appendChild map_container node;
    let dir_x, dir_y = normalize config.dir_x config.dir_y in
    {
      spec = config;
      node;
      x = config.x;
      y = config.y;
      dir_x;
      dir_y;
      time_since_last_change = 0.;
      reproduction_timer = 0.;
      status = config.status;
      grabbed = false;
      size = Settings.get_creet_size ();
    }
    |> fun creet ->
    apply_status_style creet;
    update_size creet;
    creet

  let update_position creet =
    creet.node##.style##.left := Js.string (Printf.sprintf "%gpx" creet.x);
    creet.node##.style##.top := Js.string (Printf.sprintf "%gpx" creet.y)

  let become_sick creet =
    if creet.status = Healthy then (
      let berserk_chance = Settings.get_berserk_chance () in
      let mean_chance = Settings.get_mean_chance () in
      !remove_healthy_creet_ref creet;
      let roll = (Js.math##random) *. 100. in
      if roll < berserk_chance then (
        creet.status <- Berserk)
      else if roll < berserk_chance +. mean_chance then (
        creet.status <- Mean;
        creet.size <- Settings.get_mean_size ())
      else (
        creet.status <- Sick);
      apply_status_style creet;
      update_size creet;
      !add_sick_creet_ref creet)

  let become_healthy creet =
    if creet.status <> Healthy then (
      creet.status <- Healthy;
      creet.size <- Settings.get_creet_size ();
      apply_status_style creet;
      update_size creet;
      !add_healthy_creet_ref creet;
      !remove_sick_creet_ref creet)

  let set_grabbed creet grabbed =
    creet.grabbed <- grabbed;
    apply_status_style creet

end

module%client Quadtree = struct
  type bounds = {
    x : float;
    y : float;
    width : float;
    height : float;
  }

  type t =
    | Empty
    | Leaf of { bounds : bounds; creets : Creet.t list }
    | Node of {
        bounds : bounds;
        nw : t;
        ne : t;
        sw : t;
        se : t;
      }

  let create_bounds x y width height = { x; y; width; height }

  let intersects bounds1 bounds2 =
    not
      (bounds1.x +. bounds1.width <= bounds2.x
      || bounds2.x +. bounds2.width <= bounds1.x
      || bounds1.y +. bounds1.height <= bounds2.y
      || bounds2.y +. bounds2.height <= bounds1.y)

  let get_creet_bounds (creet : Creet.t) : bounds =
    {
      x = creet.x;
      y = creet.y;
      width = creet.size;
      height = creet.size;
    }

  let max_objects = 4
  let max_depth = 6

  let subdivide bounds =
    let half_w = bounds.width /. 2. in
    let half_h = bounds.height /. 2. in
    let nw = create_bounds bounds.x bounds.y half_w half_h in
    let ne = create_bounds (bounds.x +. half_w) bounds.y half_w half_h in
    let sw = create_bounds bounds.x (bounds.y +. half_h) half_w half_h in
    let se =
      create_bounds (bounds.x +. half_w) (bounds.y +. half_h) half_w half_h
    in
    (nw, ne, sw, se)

  let rec insert (creet : Creet.t) bounds_param depth tree =
    let creet_bounds = get_creet_bounds creet in
    if not (intersects bounds_param creet_bounds) then tree
    else
      match tree with
      | Empty ->
          let creets_list : Creet.t list = [ creet ] in
          Leaf { bounds = bounds_param; creets = creets_list }
      | Leaf leaf ->
          if depth >= max_depth || List.length leaf.creets < max_objects then
            Leaf { bounds = bounds_param; creets = creet :: leaf.creets }
          else (
            let nw, ne, sw, se = subdivide bounds_param in
            let empty = Empty in
            let nw_tree = List.fold_left
                            (fun t c -> insert c nw (depth + 1) t)
                            empty leaf.creets in
            let ne_tree = List.fold_left
                            (fun t c -> insert c ne (depth + 1) t)
                            empty leaf.creets in
            let sw_tree = List.fold_left
                            (fun t c -> insert c sw (depth + 1) t)
                            empty leaf.creets in
            let se_tree = List.fold_left
                            (fun t c -> insert c se (depth + 1) t)
                            empty leaf.creets in
            insert creet bounds_param depth
              (Node {
                  bounds = bounds_param;
                  nw = nw_tree;
                  ne = ne_tree;
                  sw = sw_tree;
                  se = se_tree;
                }))
      | Node node ->
          let nw, ne, sw, se = subdivide bounds_param in
          Node
            {
              bounds = bounds_param;
              nw = insert creet nw (depth + 1) node.nw;
              ne = insert creet ne (depth + 1) node.ne;
              sw = insert creet sw (depth + 1) node.sw;
              se = insert creet se (depth + 1) node.se;
            }

  let rec query bounds tree acc =
    match tree with
    | Empty -> acc
    | Leaf leaf ->
        if intersects bounds leaf.bounds then
          List.fold_left
            (fun acc creet ->
              let creet_bounds = get_creet_bounds creet in
              if intersects bounds creet_bounds then creet :: acc else acc)
            acc leaf.creets
        else acc
    | Node node ->
        if intersects bounds node.bounds then
          query bounds node.nw acc
          |> query bounds node.ne
          |> query bounds node.sw
          |> query bounds node.se
        else acc

  let build creets =
    let bounds =
      create_bounds 0. 0. (Settings.get_map_width ()) (Settings.get_map_height ())
    in
    List.fold_left (fun tree creet -> insert creet bounds 0 tree) Empty creets

  let find_nearby creet tree =
    let creet_bounds = get_creet_bounds creet in
    query creet_bounds tree []

  let query_circle center_x center_y radius tree =
    let bounds =
      create_bounds
        (center_x -. radius)
        (center_y -. radius)
        (radius *. 2.)
        (radius *. 2.)
    in
    query bounds tree []

end

module%client State = struct
  open Js_of_ocaml
  let active_creets : Creet.t list ref = ref []
  let healthy_creets_table : (int, Creet.t) Hashtbl.t = Hashtbl.create 64
  let sick_creets_table : (int, Creet.t) Hashtbl.t = Hashtbl.create 64
  let map_container : Dom_html.divElement Js.t option ref = ref None
  let next_id = ref 0

  let register_map map = map_container := Some map

  let add_to_table table (creet : Creet.t) =
    Hashtbl.replace table creet.spec.id creet

  let remove_from_table table (creet : Creet.t) =
    Hashtbl.remove table creet.spec.id

  let set_creets (creets : Creet.t list) =
    active_creets := creets;
    Hashtbl.reset healthy_creets_table;
    Hashtbl.reset sick_creets_table;
    List.iter
      (fun (c : Creet.t) ->
        if c.status = Healthy then add_to_table healthy_creets_table c
        else add_to_table sick_creets_table c)
      creets

  let set_next_id value = next_id := value

  let fresh_id () =
    let id = !next_id in
    incr next_id;
    id

  let add_creet creet =
    active_creets := creet :: !active_creets;
    if creet.status = Healthy then add_to_table healthy_creets_table creet
    else add_to_table sick_creets_table creet

  let add_sick_creet creet = add_to_table sick_creets_table creet

  let remove_sick_creet creet = remove_from_table sick_creets_table creet

  let add_healthy_creet creet = add_to_table healthy_creets_table creet

  let remove_healthy_creet creet = remove_from_table healthy_creets_table creet

  let healthy_creets_list () =
    Hashtbl.fold (fun _ (c : Creet.t) acc -> c :: acc) healthy_creets_table []

  let healthy_creet_count () = Hashtbl.length healthy_creets_table

  let sick_creet_count () = Hashtbl.length sick_creets_table

  let iter_sick_creets f = Hashtbl.iter (fun _ creet -> f creet) sick_creets_table

  let () =
    Creet.add_sick_creet_ref := add_sick_creet;
    Creet.remove_sick_creet_ref := remove_sick_creet;
    Creet.add_healthy_creet_ref := add_healthy_creet;
    Creet.remove_healthy_creet_ref := remove_healthy_creet

  let spawn_spec spec =
    match !map_container with
    | None -> None
    | Some map ->
        let creet = Creet.spawn spec map in
        add_creet creet;
        Some creet
end

module%client Interaction = struct
  open Js_of_ocaml
  open Js_of_ocaml_lwt

  let grabbed_creet : Creet.t option ref = ref None
  let grab_offset : (float * float) option ref = ref None

  let get_map_position (ev : Dom_html.mouseEvent Js.t) =
    match !(State.map_container) with
    | None -> None
    | Some map ->
        let rect = map##getBoundingClientRect in
        let x = float_of_int ev##.clientX -. rect##.left in
        let y = float_of_int ev##.clientY -. rect##.top in
        Some (x, y)

  let clamp_to_bounds (creet : Creet.t) x y =
    let min_x = 0. in
    let min_y = 0. in
    let max_x = Settings.get_map_width () -. creet.size in
    let max_y = Settings.get_map_height () -. creet.size in
    let x = max min_x (min x max_x) in
    let y = max min_y (min y max_y) in
    (x, y)

  let check_and_heal_if_close_to_bottom (creet : Creet.t) =
    let bottom_wall_y = Settings.get_map_height () in
    let creet_bottom_y = creet.y +. creet.size in
    let distance_to_bottom = bottom_wall_y -. creet_bottom_y in
    if
      distance_to_bottom <= Settings.get_healing_distance_threshold ()
      && distance_to_bottom >= 0.
    then (
      if creet.status <> Healthy then
        Creet.become_healthy creet)

  let release_creet () =
    match !grabbed_creet with
    | None -> ()
    | Some creet ->
        Creet.set_grabbed creet false;
        check_and_heal_if_close_to_bottom creet;
        grabbed_creet := None;
        grab_offset := None;
        match !(State.map_container) with
        | None -> ()
        | Some map -> map##.classList##remove (Js.string "grabbing")

  let handle_click (ev : Dom_html.mouseEvent Js.t) =
    match get_map_position ev with
    | None -> ()
    | Some (x, y) -> (
        match !grabbed_creet with
        | Some _ -> release_creet ()
        | None -> (
          (* Use event target to find which element was clicked *)
          let clicked_element = Js.Opt.to_option ev##.target in
          match clicked_element with
          | None -> ()
          | Some element -> (
              (* Walk up the DOM tree to find an element with a creet ID *)
              let rec find_creet_id (el : Dom_html.element Js.t) =
                let id = Js.to_string el##.id in
                if String.length id > 6 && String.sub id 0 6 = "creet-" then (
                  try
                    let creet_id = int_of_string (String.sub id 6 (String.length id - 6)) in
                    Some creet_id
                  with _ -> None)
                else (
                  match Js.Opt.to_option el##.parentNode with
                  | None -> None
                  | Some parent_node -> (
                      try
                        let parent_el : Dom_html.element Js.t =
                          Js.Unsafe.coerce parent_node
                        in
                        find_creet_id parent_el
                      with _ -> None))
              in
              match find_creet_id element with
              | None -> ()
              | Some creet_id -> (
                  (* Find the Creet.t object with this ID *)
                  let creets = !(State.active_creets) in
                  let found_creet =
                    List.find_opt
                      (fun (creet : Creet.t) -> creet.spec.id = creet_id)
                      creets
                  in
                  match found_creet with
                  | None -> ()
                  | Some creet ->
                      if creet.status <> Healthy then (
                        let offset_x = x -. creet.x in
                        let offset_y = y -. creet.y in
                        grab_offset := Some (offset_x, offset_y);
                        Creet.set_grabbed creet true;
                        grabbed_creet := Some creet;
                        let console = Js.Unsafe.global##.console in
                        ignore
                          (console##log
                             (Js.string
                                ("Grab successful: Click at ("
                               ^ string_of_float x ^ ", " ^ string_of_float y
                               ^ "), grabbed creet at (" ^ string_of_float creet.x
                               ^ ", " ^ string_of_float creet.y ^ ")")));
                        match !(State.map_container) with
                        | None -> ()
                        | Some map -> map##.classList##add (Js.string "grabbing"))
                      else (
                        let console = Js.Unsafe.global##.console in
                        ignore
                          (console##log
                             (Js.string
                                ("Grab failed: Creet at ("
                               ^ string_of_float creet.x ^ ", "
                               ^ string_of_float creet.y
                               ^ ") is not sick"))))))))

  let handle_mousemove (ev : Dom_html.mouseEvent Js.t) =
    match !grabbed_creet with
    | None -> ()
    | Some creet -> (
        match get_map_position ev with
        | None -> release_creet ()
        | Some (mouse_x, mouse_y) -> (
            (* Check if cursor is outside map bounds *)
            let map_width = Settings.get_map_width () in
            let map_height = Settings.get_map_height () in
            if mouse_x < 0. || mouse_x > map_width || mouse_y < 0. || mouse_y > map_height
            then release_creet ()
            else (
              match !grab_offset with
              | None -> release_creet ()
              | Some (offset_x, offset_y) ->
                  let x = mouse_x -. offset_x in
                  let y = mouse_y -. offset_y in
                  let x, y = clamp_to_bounds creet x y in
                  creet.x <- x;
                  creet.y <- y;
                  Creet.update_position creet;
                  let min_x = 0. in
                  let min_y = 0. in
                  let max_x = Settings.get_map_width () -. creet.size in
                  let max_y = Settings.get_map_height () -. creet.size in
                  if x <= min_x || x >= max_x || y <= min_y || y >= max_y then
                    release_creet ())))

  let setup map =
    let map_element = (map :> Dom_html.element Js.t) in
    Lwt.async (fun () ->
        Lwt_js_events.mousedowns map_element (fun ev _ ->
            handle_click ev;
            Lwt.return_unit));
    Lwt.async (fun () ->
        Lwt_js_events.mousemoves map_element (fun ev _ ->
            handle_mousemove ev;
            Lwt.return_unit));
    (* Also listen to document-level mousemove to catch fast movements outside map *)
    Lwt.async (fun () ->
        Lwt_js_events.mousemoves Dom_html.document##.documentElement (fun ev _ ->
            match !grabbed_creet with
            | None -> Lwt.return_unit
            | Some _ -> (
                match get_map_position ev with
                | None -> (
                    release_creet ();
                    Lwt.return_unit)
                | Some (mouse_x, mouse_y) -> (
                    (* Check if cursor is outside map bounds *)
                    let map_width = Settings.get_map_width () in
                    let map_height = Settings.get_map_height () in
                    if mouse_x < 0. || mouse_x > map_width || mouse_y < 0. || mouse_y > map_height
                    then (
                      release_creet ();
                      Lwt.return_unit)
                    else Lwt.return_unit))))
end

module%client Counters = struct
  open Js_of_ocaml

  let healthy_counter_id = "healthy-counter"
  let sick_counter_id = "sick-counter"
  let time_counter_id = "time-counter"
  let speed_counter_id = "speed-counter"

  let update ~elapsed_time ~speed_increment =
    let healthy_count = State.healthy_creet_count () in
    let sick_count = State.sick_creet_count () in
    let healthy_elem =
      Js.Opt.to_option
        (Dom_html.document##getElementById (Js.string healthy_counter_id))
    in
    let sick_elem =
      Js.Opt.to_option
        (Dom_html.document##getElementById (Js.string sick_counter_id))
    in
    let time_elem =
      Js.Opt.to_option
        (Dom_html.document##getElementById (Js.string time_counter_id))
    in
    let speed_elem =
      Js.Opt.to_option
        (Dom_html.document##getElementById (Js.string speed_counter_id))
    in
    (match (healthy_elem, sick_elem) with
    | Some h, Some s ->
        h##.textContent :=
          Js.some (Js.string (string_of_int healthy_count));
        s##.textContent := Js.some (Js.string (string_of_int sick_count))
    | _ -> ());
    (match time_elem with
    | Some t ->
        let text = Js.string (Printf.sprintf "%.1fs" elapsed_time) in
        t##.textContent := Js.some text
    | None -> ());
    (match speed_elem with
    | Some sp ->
        let text =
          Js.string
            (Printf.sprintf "+%.2f" speed_increment)
        in
        sp##.textContent := Js.some text
    | None -> ())
end

module%client Game_loop = struct
  open Js_of_ocaml
  open Js_of_ocaml_lwt
  open Lwt.Infix

  let elapsed_time : float ref = ref 0.

  let min_x = 0.
  let min_y = 0.

  let clamp v low high =
    max low (min v high)

  let normalize dx dy =
    let mag = sqrt ((dx *. dx) +. (dy *. dy)) in
    if mag = 0. then (1., 0.) else (dx /. mag, dy /. mag)

  let reflect (creet : Creet.t) hit_x hit_y =
    if hit_x then creet.dir_x <- -.creet.dir_x;
    if hit_y then creet.dir_y <- -.creet.dir_y;
    let dir_x, dir_y = normalize creet.dir_x creet.dir_y in
    creet.dir_x <- dir_x;
    creet.dir_y <- dir_y

  let random_direction () =
    let angle = (Js.math##random) *. 2. *. 3.141592653589793 in
    normalize (cos angle) (sin angle)

  let should_turn (creet : Creet.t) =
    let threshold = Config.initial_chance +. (Config.step *. creet.time_since_last_change) in
    if threshold <= 0. then false
    else
      let clamped_threshold = min threshold Config.max_chance in
      let random_val = (Js.math##random) *. 100. in
      random_val < clamped_threshold

  let random_turn (creet : Creet.t) =
    let dir_x, dir_y = random_direction () in
    creet.dir_x <- dir_x;
    creet.dir_y <- dir_y;
    creet.time_since_last_change <- 0.

  let attempt_reproduction (creet : Creet.t) =
    if creet.status = Healthy then (
      creet.reproduction_timer <- creet.reproduction_timer +. Config.frame_duration;
      let rec loop () =
        if creet.reproduction_timer >= 1. then (
          creet.reproduction_timer <- creet.reproduction_timer -. 1.;
          let roll = (Js.math##random) *. 100. in
          if roll < Config.reproduction_chance then (
            let dir_x, dir_y = random_direction () in
            let spec =
              {
                id = State.fresh_id ();
                x = creet.x;
                y = creet.y;
                dir_x;
                dir_y;
                status = Healthy;
              }
            in
            ignore (State.spawn_spec spec));
          loop ())
      in
      loop ())
  let handle_bounds (creet : Creet.t) =
    let max_x_actual = Settings.get_map_width () -. creet.size in
    let max_y_actual = Settings.get_map_height () -. creet.size in
    let hit_left = creet.x <= min_x && creet.dir_x < 0. in
    let hit_right = creet.x >= max_x_actual && creet.dir_x > 0. in
    let hit_top = creet.y <= min_y && creet.dir_y < 0. in
    let hit_bottom = creet.y >= max_y_actual && creet.dir_y > 0. in
    let hit_x = hit_left || hit_right in
    let hit_y = hit_top || hit_bottom in
    if hit_x || hit_y then (
      reflect creet hit_x hit_y;
      if hit_top then Creet.become_sick creet;
      creet.x <- clamp creet.x min_x max_x_actual;
      creet.y <- clamp creet.y min_y max_y_actual)

  let creets_collide (creet1 : Creet.t) (creet2 : Creet.t) =
    let dx = creet2.x -. creet1.x in
    let dy = creet2.y -. creet1.y in
    let distance_squared = (dx *. dx) +. (dy *. dy) in
    let radius1 = creet1.size /. 2. in
    let radius2 = creet2.size /. 2. in
    let radius_sum = radius1 +. radius2 in
    let radius_sum_squared = radius_sum *. radius_sum in
    distance_squared <= radius_sum_squared

  let handle_collisions tree =
    State.iter_sick_creets
      (fun (sick_creet : Creet.t) ->
        if not sick_creet.grabbed then (
          let nearby = Quadtree.find_nearby sick_creet tree in
          List.iter
            (fun (other_creet : Creet.t) ->
              if creets_collide sick_creet other_creet then (
                let roll = (Js.math##random) *. 100. in
                if roll < Config.infection_chance then Creet.become_sick other_creet))
            nearby))

  let find_closest_healthy_creet (creet : Creet.t) (tree : Quadtree.t) =
    let creet_center_x = creet.x +. (creet.size /. 2.) in
    let creet_center_y = creet.y +. (creet.size /. 2.) in
    let detection_radius = Settings.get_mean_detection_radius () in
    let detection_radius_squared = detection_radius *. detection_radius in
    (* Use quadtree to find creets within detection radius *)
    let nearby_creets : Creet.t list =
      Quadtree.query_circle creet_center_x creet_center_y detection_radius tree
    in
    (* nearby_creets already contains only healthy creets; find closest *)
    let rec find_closest
        (best_creet : Creet.t option)
        (best_distance_squared : float)
        (remaining : Creet.t list) =
      match remaining with
      | [] -> best_creet
      | (other : Creet.t) :: rest ->
          let other_center_x = other.x +. (other.size /. 2.) in
          let other_center_y = other.y +. (other.size /. 2.) in
          let dx = other_center_x -. creet_center_x in
          let dy = other_center_y -. creet_center_y in
          let distance_squared = (dx *. dx) +. (dy *. dy) in
          if distance_squared <= detection_radius_squared
             && (best_creet = None || distance_squared < best_distance_squared)
          then find_closest (Some other) distance_squared rest
          else find_closest best_creet best_distance_squared rest
    in
    find_closest None 1e10 nearby_creets

  let advance (creet : Creet.t) (tree : Quadtree.t) =
    if creet.grabbed then (
      Creet.update_position creet)
    else (
      creet.time_since_last_change <- creet.time_since_last_change +. Config.frame_duration;
      (* Mean creets target closest healthy creet *)
      if creet.status = Mean then (
        match find_closest_healthy_creet creet tree with
        | None -> if should_turn creet then random_turn creet
        | Some target ->
            let creet_center_x = creet.x +. (creet.size /. 2.) in
            let creet_center_y = creet.y +. (creet.size /. 2.) in
            let target_center_x = target.x +. (target.size /. 2.) in
            let target_center_y = target.y +. (target.size /. 2.) in
            let dx = target_center_x -. creet_center_x in
            let dy = target_center_y -. creet_center_y in
            let dir_x, dir_y = normalize dx dy in
            creet.dir_x <- dir_x;
            creet.dir_y <- dir_y;
            creet.time_since_last_change <- 0.)
      else if should_turn creet then random_turn creet;
      attempt_reproduction creet;
      (* Grow berserk creets over time *)
      if creet.status = Berserk then (
        let max_size =
          Settings.get_creet_size () +. Settings.get_berserk_extra_size ()
        in
        if creet.size < max_size then (
          let increment =
            Settings.get_berserk_size_increment () *. Config.frame_duration
          in
          creet.size <- min max_size (creet.size +. increment);
          Creet.update_size creet));
      let speed_base = Settings.get_speed () in
      let speed_increment_per_second = Settings.get_speed_increment_per_second () in
      let current_speed =
        speed_base +. (speed_increment_per_second *. !elapsed_time)
      in
      let step =
        current_speed
        *. (if creet.status <> Healthy then Settings.get_sick_speed_modifier ()
           else 1.)
        *. Config.frame_duration
      in
      creet.x <- creet.x +. (creet.dir_x *. step);
      creet.y <- creet.y +. (creet.dir_y *. step);
      let max_x_actual = Settings.get_map_width () -. creet.size in
      let max_y_actual = Settings.get_map_height () -. creet.size in
      creet.x <- clamp creet.x min_x max_x_actual;
      creet.y <- clamp creet.y min_y max_y_actual;
      handle_bounds creet;
      Creet.update_position creet)

  let rec tick () =
    elapsed_time := !elapsed_time +. Config.frame_duration;
    (* Build quadtree with only healthy creets for targeting/infection *)
    let tree = Quadtree.build (State.healthy_creets_list ()) in
    List.iter (fun creet -> advance creet tree) !(State.active_creets);
    handle_collisions tree;
    let speed_increment =
      Settings.get_speed_increment_per_second () *. !elapsed_time
    in
    Counters.update ~elapsed_time:!elapsed_time ~speed_increment;
    Lwt_js.sleep Config.frame_duration >>= tick

  let start () = Lwt.async (fun () -> tick ())
end

module%client World = struct
  open Js_of_ocaml

  let root_id = "app-root"
  let started = ref false

  let get_root () =
    Js.Opt.to_option
      (Dom_html.document##getElementById (Js.string root_id))

  let mount () =
    if !started then ()
    else (
      started := true;
      match get_root () with
      | None -> ()
      | Some root ->
          let map = Map_canvas.create_empty () in
          Dom.appendChild root map;
          State.register_map map;
          Interaction.setup map;
          let shared_creets = ~%initial_creets in
          let next_id =
            List.fold_left (fun acc spec -> max acc spec.id) 0 shared_creets + 1
          in
          State.set_next_id next_id;
          let creets =
            List.map (fun spec -> Creet.spawn spec map) shared_creets
          in
          State.set_creets creets;
          Game_loop.start ();
    )
end

module%client Menu = struct
  open Js_of_ocaml

  let menu_id = "menu-screen"
  let game_ui_id = "game-ui"
  let width_input_id = "map-width-input"
  let height_input_id = "map-height-input"
  let speed_input_id = "speed-input"
  let sick_speed_input_id = "sick-speed-input"
  let speed_increment_input_id = "speed-increment-input"
  let berserk_chance_input_id = "berserk-chance-input"
  let mean_chance_input_id = "mean-chance-input"
  let berserk_increment_input_id = "berserk-size-increment-input"
  let play_button_id = "play-button"
  let reset_button_id = "reset-button"

  let get_element id =
    Js.Opt.to_option
      (Dom_html.document##getElementById (Js.string id))

  let get_input id =
    match get_element id with
    | None -> None
    | Some el -> Js.Opt.to_option (Dom_html.CoerceTo.input el)

  let set_input_attribute input name value =
    ignore (input##setAttribute (Js.string name) (Js.string value))

  let configure_inputs () =
    (match get_input width_input_id with
    | Some input ->
        set_input_attribute input "min" "100";
        set_input_attribute input "step" "10"
    | None -> ());
    (match get_input height_input_id with
    | Some input ->
        set_input_attribute input "min" "100";
        set_input_attribute input "step" "10"
    | None -> ());
    (match get_input speed_input_id with
    | Some input ->
        set_input_attribute input "min" "1";
        set_input_attribute input "step" "1"
    | None -> ());
    (match get_input sick_speed_input_id with
    | Some input ->
        set_input_attribute input "min" "0.1";
        set_input_attribute input "max" "1";
        set_input_attribute input "step" "0.01"
    | None -> ());
    (match get_input speed_increment_input_id with
    | Some input ->
        set_input_attribute input "min" "0";
        set_input_attribute input "step" "0.1"
    | None -> ());
    (match get_input berserk_chance_input_id with
    | Some input ->
        set_input_attribute input "min" "0";
        set_input_attribute input "max" "100";
        set_input_attribute input "step" "1"
    | None -> ());
    (match get_input mean_chance_input_id with
    | Some input ->
        set_input_attribute input "min" "0";
        set_input_attribute input "max" "100";
        set_input_attribute input "step" "1"
    | None -> ());
    (match get_input berserk_increment_input_id with
    | Some input ->
        set_input_attribute input "min" "0.01";
        set_input_attribute input "step" "0.1"
    | None -> ())

  let add_class el cls = ignore (el##.classList##add (Js.string cls))
  let remove_class el cls = ignore (el##.classList##remove (Js.string cls))

  let show_game_ui () =
    match get_element game_ui_id with
    | Some el -> remove_class el "hidden"
    | None -> ()

  let hide_menu () =
    match get_element menu_id with
    | Some el -> add_class el "hidden"
    | None -> ()

  let format_float value =
    let fractional = abs_float (value -. floor value) in
    if fractional < 0.001 then Printf.sprintf "%.0f" value
    else Printf.sprintf "%.2f" value

  let set_input_value id value =
    match get_input id with
    | Some input -> input##.value := Js.string (format_float value)
    | None -> ()

  let clamp value min_value max_value =
    let v = if value < min_value then min_value else value in
    match max_value with
    | None -> v
    | Some max_v -> if v > max_v then max_v else v

  let parse_float_with_limits id ~default ~min_value ~max_value =
    match get_input id with
    | None -> default
    | Some input ->
        let raw = Js.to_string input##.value in
        try
          let v = float_of_string raw in
          clamp v min_value max_value
        with _ -> default

  let parse_dimension id default =
    parse_float_with_limits id ~default ~min_value:100. ~max_value:None

  let parse_range id default ~min_value ~max_value =
    parse_float_with_limits id ~default ~min_value:(min_value) ~max_value:(Some max_value)

  let parse_percentage id default =
    parse_float_with_limits id ~default ~min_value:0. ~max_value:(Some 100.)

  let handle_reset _ =
    Settings.reset ();
    set_input_value width_input_id (Settings.get_default_map_width ());
    set_input_value height_input_id (Settings.get_default_map_height ());
    set_input_value speed_input_id (Settings.get_default_speed ());
    set_input_value sick_speed_input_id (Settings.get_default_sick_speed_modifier ());
    set_input_value speed_increment_input_id (Settings.get_default_speed_increment ());
    set_input_value berserk_chance_input_id (Settings.get_default_berserk_chance ());
    set_input_value mean_chance_input_id (Settings.get_default_mean_chance ());
    set_input_value berserk_increment_input_id (Settings.get_default_berserk_size_increment ());
    Js._false

  let handle_play _ =
    let width = parse_dimension width_input_id (Settings.get_map_width ()) in
    let height =
      parse_dimension height_input_id (Settings.get_map_height ())
    in
    let speed =
      parse_float_with_limits speed_input_id
        ~default:(Settings.get_speed ()) ~min_value:1. ~max_value:None
    in
    let sick_modifier =
      parse_range sick_speed_input_id (Settings.get_sick_speed_modifier ())
        ~min_value:0.1 ~max_value:1.
    in
    let speed_increment =
      parse_float_with_limits speed_increment_input_id
        ~default:(Settings.get_speed_increment_per_second ()) ~min_value:0.
        ~max_value:None
    in
    let berserk_chance =
      parse_percentage berserk_chance_input_id (Settings.get_berserk_chance ())
    in
    let mean_chance =
      parse_percentage mean_chance_input_id (Settings.get_mean_chance ())
    in
    let berserk_increment =
      parse_float_with_limits berserk_increment_input_id
        ~default:(Settings.get_berserk_size_increment ()) ~min_value:0.01
        ~max_value:None
    in
    Settings.set_map_width width;
    Settings.set_map_height height;
    Settings.set_speed speed;
    Settings.set_sick_speed_modifier sick_modifier;
    Settings.set_speed_increment_per_second speed_increment;
    Settings.set_berserk_chance berserk_chance;
    Settings.set_mean_chance mean_chance;
    Settings.set_berserk_size_increment berserk_increment;
    hide_menu ();
    show_game_ui ();
    World.mount ();
    Js._false

  let attach_click id handler =
    match get_element id with
    | None -> ()
    | Some el ->
        ignore
          (Dom_html.addEventListener el Dom_html.Event.click
             (Dom_html.handler handler) Js._false)

  let init () =
    configure_inputs ();
    set_input_value width_input_id (Settings.get_map_width ());
    set_input_value height_input_id (Settings.get_map_height ());
    set_input_value speed_input_id (Settings.get_speed ());
    set_input_value sick_speed_input_id (Settings.get_sick_speed_modifier ());
    set_input_value speed_increment_input_id
      (Settings.get_speed_increment_per_second ());
    set_input_value berserk_chance_input_id (Settings.get_berserk_chance ());
    set_input_value mean_chance_input_id (Settings.get_mean_chance ());
    set_input_value berserk_increment_input_id (Settings.get_berserk_size_increment ());
    attach_click play_button_id handle_play;
    attach_click reset_button_id handle_reset
end

let%client () =
  let open Js_of_ocaml in
  let handler _ =
    Menu.init ();
    Js._false
  in
  Dom_html.window##.onload := Dom_html.handler handler

let%server main_service =
  Eliom_service.create ~path:(Eliom_service.Path [])
    ~meth:(Eliom_service.Get Eliom_parameter.unit) ()

let%client main_service = ~%main_service

let%shared () =
  App.register ~service:main_service (fun () () ->
    Lwt.return
      Html.(
        html
          (head
             (title (txt "Creet MVP"))
             [
               css_link
                 ~uri:
                   (make_uri
                      ~service:(Eliom_service.static_dir ())
                      ["css"; "creet_app.css"])
                 ();
             ])
          (body
             [
               h1 [txt "Creet MVP"];
              div
                ~a:[a_id "menu-screen"; a_class ["menu-screen"]]
                [
                  h2 [txt "Settings"];
                  div
                    ~a:[a_class ["menu__section"]]
                    [
                      h3 [txt "Map"];
                      div
                        ~a:[a_class ["menu__group"]]
                        [
                          label ~a:[a_label_for "map-width-input"] [txt "Map width (px)"];
                          input
                            ~a:[
                              a_id "map-width-input";
                              a_input_type `Number;
                            ]
                            ();
                        ];
                      div
                        ~a:[a_class ["menu__group"]]
                        [
                          label ~a:[a_label_for "map-height-input"] [txt "Map height (px)"];
                          input
                            ~a:[
                              a_id "map-height-input";
                              a_input_type `Number;
                            ]
                            ();
                        ];
                    ];
                  div
                    ~a:[a_class ["menu__section"]]
                    [
                      h3 [txt "Movement"];
                      div
                        ~a:[a_class ["menu__group"]]
                        [
                          label ~a:[a_label_for "speed-input"] [txt "Base speed"];
                          input
                            ~a:[
                              a_id "speed-input";
                              a_input_type `Number;
                            ]
                            ();
                        ];
                      div
                        ~a:[a_class ["menu__group"]]
                        [
                          label ~a:[a_label_for "sick-speed-input"] [txt "Sick speed modifier (0.1 - 1.0)"];
                          input
                            ~a:[
                              a_id "sick-speed-input";
                              a_input_type `Range;
                            ]
                            ();
                        ];
                      div
                        ~a:[a_class ["menu__group"]]
                        [
                          label ~a:[a_label_for "berserk-chance-input"] [txt "Berserk chance (%)"];
                          input
                            ~a:[
                              a_id "berserk-chance-input";
                              a_input_type `Range;
                            ]
                            ();
                        ];
                      div
                        ~a:[a_class ["menu__group"]]
                        [
                          label ~a:[a_label_for "mean-chance-input"] [txt "Mean chance (%)"];
                          input
                            ~a:[
                              a_id "mean-chance-input";
                              a_input_type `Range;
                            ]
                            ();
                        ];
                      div
                        ~a:[a_class ["menu__group"]]
                        [
                          label ~a:[a_label_for "berserk-size-increment-input"] [txt "Berserk size increment / s"];
                          input
                            ~a:[
                              a_id "berserk-size-increment-input";
                              a_input_type `Number;
                            ]
                            ();
                        ];
                      div
                        ~a:[a_class ["menu__group"]]
                        [
                          label ~a:[a_label_for "speed-increment-input"] [txt "Speed increment per second"];
                          input
                            ~a:[
                              a_id "speed-increment-input";
                              a_input_type `Number;
                            ]
                            ();
                        ];
                    ];
                  div
                    ~a:[a_class ["menu__actions"]]
                    [
                      button ~a:[a_id "reset-button"; a_class ["menu__button"]] [txt "Reset"];
                      button ~a:[a_id "play-button"; a_class ["menu__button"; "menu__button--primary"]] [txt "Play"];
                    ];
                ];
               div
                 ~a:[a_id "game-ui"; a_class ["game-ui"; "hidden"]]
                 [
                   div
                     ~a:[
                       a_id "app-root";
                       a_class ["app-root"];
                       a_user_data
                         "creet-count"
                         (string_of_int (List.length initial_creets));
                     ]
                     [];
                   div
                     ~a:[
                       a_id "healthy-counter";
                       a_class ["counter"; "counter--healthy"];
                     ]
                     [txt "0"];
                   div
                     ~a:[
                       a_id "sick-counter";
                       a_class ["counter"; "counter--sick"];
                     ]
                     [txt "0"];
                   div
                     ~a:[
                       a_id "time-counter";
                       a_class ["counter"; "counter--time"];
                     ]
                     [txt "0s"];
                   div
                     ~a:[
                       a_id "speed-counter";
                       a_class ["counter"; "counter--speed"];
                     ]
                     [txt "+0"];
                 ];
             ])))
